<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel Tempering (PT) · Pigeons.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Julia-Tempering.github.io/Pigeons.jl/pt/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Pigeons.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Guide</a></li><li class="is-active"><a class="tocitem" href>Parallel Tempering (PT)</a><ul class="internal"><li><a class="tocitem" href="#PT-augmented-state-space,-replicas"><span>PT augmented state space, replicas</span></a></li><li><a class="tocitem" href="#Local-exploration-and-communication"><span>Local exploration and communication</span></a></li><li><a class="tocitem" href="#Basic-PT-algorithm"><span>Basic PT algorithm</span></a></li><li><a class="tocitem" href="#Adaptation-and-schedule-update"><span>Adaptation and schedule update</span></a></li></ul></li><li><a class="tocitem" href="../distributed/">Distributed PT</a></li><li><a class="tocitem" href="../.interfaces/">Interfaces</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Parallel Tempering (PT)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parallel Tempering (PT)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/main/docs/src/pt.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>We provide in this page an overview of Non-Reversible Parallel Tempering (PT),  <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al., 2021</a>,  linking it with some key parts of the code base. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Read this page if you are interested in extending Pigeons or  understanding how it works under the hood.  Reading this page is not required to use Pigeons, for that instead refer to the  <a href="../index.html">user guide</a>. </p></div></div><h2 id="PT-augmented-state-space,-replicas"><a class="docs-heading-anchor" href="#PT-augmented-state-space,-replicas">PT augmented state space, replicas</a><a id="PT-augmented-state-space,-replicas-1"></a><a class="docs-heading-anchor-permalink" href="#PT-augmented-state-space,-replicas" title="Permalink"></a></h2><p>Let <span>$X_n$</span> denote a Markov chain on state space <span>$\mathscr{X}$</span> with stationary distribution <span>$\pi$</span>.  PT is a Markov chain defined on the augmented state space <span>$\mathscr{X}^N$</span>, hence  a state has the form <span>$\boldsymbol{X} = (X^{(1)}, X^{(2)}, \dots, X^{(N)})$</span>.  Each component of <span>$\boldsymbol{X}$</span> is stored in a struct called a <a href="../reference/#Pigeons.Replica"><code>Replica</code></a>. </p><p>The storage of the vector of replicas <span>$\boldsymbol{X}$</span>, is done via the informal  interface <a href="../.interfaces/#Pigeons.replicas"><code>replicas</code></a>. In the context of PT running on one computer,  <a href="../.interfaces/#Pigeons.replicas"><code>replicas</code></a> is implemented with a <code>Vector{Replica}</code>. In the context  of running PT distributed across several communicating machines, <a href="../.interfaces/#Pigeons.replicas"><code>replicas</code></a>  is implemented via <a href="../reference/#Pigeons.EntangledReplicas"><code>EntangledReplicas</code></a>, which stores the parts of  <span>$\boldsymbol{X}$</span> that are local to that machine as well as data structures  required to communicate with the other machines. </p><p>Internally, PT operates on a discrete set of distributions,  <span>$\pi_1, \pi_2, \dots \pi_N$</span>, where <span>$N$</span> can be obtained using <a href="../reference/#Pigeons.n_chains_global-Tuple{Any}"><code>n_chains_global()</code></a>.  We use the terminology chain to refer to an index <span>$i$</span> of <span>$\pi_i$</span>. Typically, <span>$\pi_N$</span> coincides with the distribution of interest <span>$\pi$</span> (called the &quot;target&quot;), while  <span>$\pi_1$</span> is a tractable approximation that will help PT efficiently explore the  state space (called the &quot;reference&quot;).  More broadly, we assume a subset of the chains (given by <a href="../reference/#Pigeons.target_chains-Tuple{Any}"><code>target_chains()</code></a>) coincide with the target, and that a subset of the chains (given by <a href="../reference/#Pigeons.reference_chains-Tuple{Any}"><code>reference_chains()</code></a>) support  efficient exploration such as i.i.d. sampling or a rapid mixing kernel. </p><p>PT is designed so that its stationary distribution is <span>$\boldsymbol{\pi} = \pi_1 \times \pi_2 \times \dots \pi_N$</span>.  As a result, subsetting each sample to its component corresponding to <span>$\pi_N = \pi$</span>,  and applying an integrable function <span>$f$</span> to each, will lead under weak assumptions  to Monte Carlo averages that converge to the expectation of interest <span>$E[f(X)]$</span> for  <span>$X \sim \pi$</span>.</p><h2 id="Local-exploration-and-communication"><a class="docs-heading-anchor" href="#Local-exploration-and-communication">Local exploration and communication</a><a id="Local-exploration-and-communication-1"></a><a class="docs-heading-anchor-permalink" href="#Local-exploration-and-communication" title="Permalink"></a></h2><p>PT alternates between two phases, each <span>$\boldsymbol{\pi}$</span>-invariant: the local  exploration phase and the communication phase. Informally, the first phase attempts to achieve  mixing for the univariate statistics <span>$\pi_i(X^{(i)})$</span>, while the second phase attempts to  translate well-mixing of these univariate statistics into global mixing of <span>$X^{(i)}$</span> by  leveraging the reference distribution(s).</p><h3 id="Local-exploration"><a class="docs-heading-anchor" href="#Local-exploration">Local exploration</a><a id="Local-exploration-1"></a><a class="docs-heading-anchor-permalink" href="#Local-exploration" title="Permalink"></a></h3><p>In the <strong>local exploration phase</strong>, each <a href="../reference/#Pigeons.Replica"><code>Replica</code></a>&#39;s state is modified using a <span>$\pi_i$</span>-invariant kernel,  where <span>$i$</span> is given by <code>Replica.chain</code>. Often, <code>Replica.chain</code> corresponds to  an annealing parameter <span>$\beta_i$</span> but this need not be the case (see  e.g. <a href="https://arxiv.org/abs/1108.3423">Baragatti et al., 2011</a>). The kernel can either modify <code>Replica.state</code> in-place, or modify the  <code>Replica</code>&#39;s <code>state</code> field.</p><div class="admonition is-warning"><header class="admonition-header">TODO</header><div class="admonition-body"><p>More details about local exploration once the architecture of that  part of the code is more fleshed out...</p></div></div><h3 id="Communication"><a class="docs-heading-anchor" href="#Communication">Communication</a><a id="Communication-1"></a><a class="docs-heading-anchor-permalink" href="#Communication" title="Permalink"></a></h3><p>In the <strong>communication phase</strong>, PT proposes swaps between pairs of replicas.  These swaps allow each replica&#39;s state to periodically visit reference chains. During these reference visits, the state can move around the space quickly.  In principle, there are two equivalent ways to do a swap: the <code>Replica</code>s could exchange  their <code>state</code> fields; or alternatively, they could exchange their <code>chain</code> fields. Since we provide distributed implementations, we use the latter as it ensures that  the amount of data that needs to be exchanged between two machines during a swap  can be made very small (two floats).  It is remarkable that this cost does not vary with the dimensionality of the state space,  in constrast to the naive implementation which would transmit states over the network. See <a href="distributed.html">Distributed PT</a> for more information on our distributed implementation.</p><p>Both in distributed and single process mode,  swaps are performed using the function <a href="../reference/#Pigeons.swap!-Tuple{Any, Any, Any}"><code>swap!()</code></a>. See the documentation there for more information.</p><h2 id="Basic-PT-algorithm"><a class="docs-heading-anchor" href="#Basic-PT-algorithm">Basic PT algorithm</a><a id="Basic-PT-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-PT-algorithm" title="Permalink"></a></h2><p>Here is a simplified example of how Algorithm 1 in <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al., 2021</a>  can be implemented in Pigeons. (This example is for pedagogy and/or those interested in extending  the library. Users of the library should instead follow higher-level instructions in <a href="../index.html">the user guide page</a>.)</p><pre><code class="language- hljs">using Pigeons
using SplittableRandoms
using Plots
import Base.Threads.@threads

const n_chains = 20

# initialize sequence of distributions
const dim = 8
const normal_log_potentials = scaled_normal_example(n_chains, dim)

# initialize replicas
const init = Ref(zeros(dim))               # initialize all states to zero
const rng = SplittableRandom(1)            # specialized rng (see Distributed PT page)
const keys = recorder_keys(:index_process) # determines which statistics to keep

function simple_deo(n_iters, log_potentials)
    replicas = create_vector_replicas(n_chains, init, rng, keys)
    for iteration in 1:n_iters
        # communication phase
        swap!(log_potentials, replicas, deo(n_chains, iteration))
        # toy local exploration (in this toy e.g. we can do iid for all chains)
        @threads for replica in locals(replicas)
            distribution = log_potentials[replica.chain]
            replica.state = rand(replica.rng, distribution)
        end
    end
    return reduced_recorders(replicas)
end

deo_result = simple_deo(100, normal_log_potentials)
p = index_process_plot(deo_result)
savefig(p, &quot;index_process.svg&quot;); nothing # hide</code></pre><p><img src="index_process.svg" alt/></p><p>The code above illustrates the two steps needed to collect statistics from the execution of a PT algorithm: </p><ul><li>We specify which statistics to collect using <a href="../reference/#Pigeons.recorder_keys-Tuple{Vararg{Symbol}}"><code>recorder_keys()</code></a> (by    default, those that can be computed in constant memory only are included,    those that have growing memory consumption, e.g. tracking the full    index process as done here, need to be explicitly specified in advance).</li><li>Using <a href="../reference/#Pigeons.reduced_recorders-Tuple{Any}"><code>reduced_recorders()</code></a> to compile the statistics collected    by the different replicas.</li></ul><p>An object responsible for accumulating all different types of statistics for  one replica is called a  <a href="../.interfaces/#Pigeons.recorders"><code>recorders</code></a>. An object accumulating one  type of statistic for one replica is a <a href="../.interfaces/#Pigeons.recorder"><code>recorder</code></a>.  Each replica has a single recorders to ensure thread safety (as illustrated above  by the use of a parallel local exploration phase using <code>@thread</code>) and to enable distributed  computing. </p><h2 id="Adaptation-and-schedule-update"><a class="docs-heading-anchor" href="#Adaptation-and-schedule-update">Adaptation and schedule update</a><a id="Adaptation-and-schedule-update-1"></a><a class="docs-heading-anchor-permalink" href="#Adaptation-and-schedule-update" title="Permalink"></a></h2><p>PT requires as input a discrete set of probability distribution, i.e. <a href="../.interfaces/#Pigeons.log_potentials"><code>log_potentials</code></a>.  How can those be automatically computed from just knowing the reference and target  distributions? This section outlines this process.</p><p>The starting point is a <a href="../.interfaces/#Pigeons.path"><code>path</code></a> object, which is a continuum of distributions.  A <a href="../.interfaces/#Pigeons.path"><code>path</code></a> is typically obtained via <a href="../reference/#Pigeons.create_path"><code>create_path()</code></a>.  We can also get a toy example consisting of normal distributions with varying  precision parameters via <a href="../reference/#Pigeons.scaled_normal_example-Tuple{Any, Any}"><code>scaled_normal_example()</code></a>, which is what we  will use here.</p><p>We now move to a simplified version of Algorithms 2 and 3 in <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al., 2021</a>  (again for pedagogy and/or those interested in extending the library), which are  algorithms for adaptively discretizing a continuum of distributions.</p><p>The algorithm starts with a simple initial discretization. Here it is one where each grid is equally spaced, being built using <a href="../reference/#Pigeons.Schedule"><code>Schedule()</code></a> and <a href="../reference/#Pigeons.discretize-Tuple{Any, Schedule}"><code>discretize()</code></a>:</p><pre><code class="language- hljs"># continues from the above
path = ScaledPrecisionNormalPath(dim)
schedule = Schedule(n_chains)
log_potentials = discretize(path, schedule)
nothing # hide</code></pre><p>we then run one <em>round</em> of Algorithm 1, and use its output to  compute an initial estimate of the communication barriers as defined  in <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Section 4 of Syed et al., 2021</a>  and implemented in <a href="../reference/#Pigeons.communicationbarrier-Tuple{AbstractVector, AbstractVector}"><code>communicationbarrier()</code></a>.</p><pre><code class="language- hljs"># continues from the above
deo_result = simple_deo(100, log_potentials)
barriers = communicationbarrier(deo_result, schedule)
plot(barriers.cumulativebarrier, legend = false)
xlims!(0, 1)
savefig(&quot;barrier.svg&quot;) # hide
barriers.globalbarrier</code></pre><p><img src="barrier.svg" alt/></p><p>We can then create a new schedule from the cumulative communication barrier  by following <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Algorithm 2 of Syed et al., 2021</a>  and implemented in <a href="../reference/#Pigeons.Schedule"><code>Schedule()</code></a>.  Finally, following <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Algorithm 4 of Syed et al., 2021</a>  we can iterate this process by performing several rounds of PT, each with increasing budget:</p><pre><code class="language- hljs"># continues from the above

function adapt(schedule, n_iters)
    log_potentials = discretize(path, schedule)
    deo_result = simple_deo(n_iters, log_potentials)
    barriers = communicationbarrier(deo_result, schedule)
    plot!(barriers.cumulativebarrier)
    xlims!(0, 1)
    return (Schedule(n_chains, barriers.cumulativebarrier), barriers)
end

function nrpt(schedule)
    n_iters = 2
    for round_index in 1:10
        schedule, barriers = adapt(schedule, n_iters)
        n_iters *= 2
    end
    return barriers
end

plot()
barriers = nrpt(schedule)

savefig(&quot;barriers.svg&quot;); nothing # hide</code></pre><p><img src="barriers.svg" alt/></p><p>The simple normal model we are using has a <a href="https://aip.scitation.org/doi/10.1063/1.1644093">known closed-form expression</a>  for the cumulative barrier. We can use this closed-form expression to check the  accuracy of our PT-derived approximation:</p><pre><code class="language- hljs"># continues from the above
analytic = analytic_cumulativebarrier(path)
plot([analytic, barriers.cumulativebarrier], labels = [&quot;analytic&quot; &quot;estimate&quot;])
xlims!(0, 1)
savefig(&quot;compare-barriers.svg&quot;); nothing # hide</code></pre><p><img src="compare-barriers.svg" alt/></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Guide</a><a class="docs-footer-nextpage" href="../distributed/">Distributed PT »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 6 January 2023 20:00">Friday 6 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
