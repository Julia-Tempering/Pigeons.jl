<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parallel Tempering (PT) · Pigeons.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Julia-Tempering.github.io/Pigeons.jl/pt/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Pigeons.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Guide</a></li><li class="is-active"><a class="tocitem" href>Parallel Tempering (PT)</a><ul class="internal"><li><a class="tocitem" href="#PT-augmented-state-space,-replicas"><span>PT augmented state space, replicas</span></a></li><li><a class="tocitem" href="#Outline-of-local-exploration-and-communication"><span>Outline of local exploration and communication</span></a></li><li><a class="tocitem" href="#A-tour-of-the-PT-meta-algorithm"><span>A tour of the PT meta-algorithm</span></a></li></ul></li><li><a class="tocitem" href="../distributed/">Distributed PT</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Parallel Tempering (PT)</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parallel Tempering (PT)</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/main/docs/src/pt.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>We provide in this page an overview of Non-Reversible Parallel Tempering (PT),  <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al., 2021</a>,  linking it with some key parts of the code base. </p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Read this page if you are interested in extending Pigeons or  understanding how it works under the hood.  Reading this page is not required to use Pigeons, for that instead refer to the  <a href="../index.html">user guide</a>. </p></div></div><h2 id="PT-augmented-state-space,-replicas"><a class="docs-heading-anchor" href="#PT-augmented-state-space,-replicas">PT augmented state space, replicas</a><a id="PT-augmented-state-space,-replicas-1"></a><a class="docs-heading-anchor-permalink" href="#PT-augmented-state-space,-replicas" title="Permalink"></a></h2><p>Let <span>$X_n$</span> denote a Markov chain on state space <span>$\mathscr{X}$</span> with stationary distribution <span>$\pi$</span>.  PT is a Markov chain defined on the augmented state space <span>$\mathscr{X}^N$</span>, hence  a state has the form <span>$\boldsymbol{X} = (X^{(1)}, X^{(2)}, \dots, X^{(N)})$</span>.  Each component of <span>$\boldsymbol{X}$</span> is stored in a struct called a <a href="../reference/#Pigeons.Replica"><code>Replica</code></a>. </p><p>The storage of the vector of replicas <span>$\boldsymbol{X}$</span>, is done via the informal  interface <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a>. In the context of PT running on one computer,  <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a> is implemented with a <code>Vector{Replica}</code>. In the context  of running PT distributed across several communicating machines, <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a>  is implemented via <a href="../reference/#Pigeons.EntangledReplicas"><code>EntangledReplicas</code></a>, which stores the parts of  <span>$\boldsymbol{X}$</span> that are local to that machine as well as data structures  required to communicate with the other machines. </p><p>Internally, PT operates on a discrete set of distributions,  <span>$\pi_1, \pi_2, \dots \pi_N$</span>, where <span>$N$</span> can be obtained using <a href="../reference/#Pigeons.n_chains-Tuple{Any}"><code>n_chains()</code></a>.  We use the terminology chain to refer to an index <span>$i$</span> of <span>$\pi_i$</span>. Typically, <span>$\pi_N$</span> coincides with the distribution of interest <span>$\pi$</span> (called the &quot;target&quot;), while  <span>$\pi_1$</span> is a tractable approximation that will help PT efficiently explore the  state space (called the &quot;reference&quot;).  More broadly, we assume a subset of the chains (given by <a href="../reference/#Pigeons.target_chains-Tuple{Any, Any}"><code>target_chains()</code></a>) coincide with the target, and that a subset of the chains (given by <a href="../reference/#Pigeons.reference_chains-Tuple{Any, Any}"><code>reference_chains()</code></a>) support  efficient exploration such as i.i.d. sampling or a rapid mixing kernel. </p><p>PT is designed so that its stationary distribution is <span>$\boldsymbol{\pi} = \pi_1 \times \pi_2 \times \dots \pi_N$</span>.  As a result, subsetting each sample to its component corresponding to <span>$\pi_N = \pi$</span>,  and applying an integrable function <span>$f$</span> to each, will lead under weak assumptions  to Monte Carlo averages that converge to the expectation of interest <span>$E[f(X)]$</span> for  <span>$X \sim \pi$</span>.</p><h2 id="Outline-of-local-exploration-and-communication"><a class="docs-heading-anchor" href="#Outline-of-local-exploration-and-communication">Outline of local exploration and communication</a><a id="Outline-of-local-exploration-and-communication-1"></a><a class="docs-heading-anchor-permalink" href="#Outline-of-local-exploration-and-communication" title="Permalink"></a></h2><p>PT alternates between two phases, each <span>$\boldsymbol{\pi}$</span>-invariant: the local  exploration phase and the communication phase. Informally, the first phase attempts to achieve  mixing for the univariate statistics <span>$\pi_i(X^{(i)})$</span>, while the second phase attempts to  translate well-mixing of these univariate statistics into global mixing of <span>$X^{(i)}$</span> by  leveraging the reference distribution(s).</p><h3 id="Local-exploration"><a class="docs-heading-anchor" href="#Local-exploration">Local exploration</a><a id="Local-exploration-1"></a><a class="docs-heading-anchor-permalink" href="#Local-exploration" title="Permalink"></a></h3><p>In the <strong>local exploration phase</strong>, each <a href="../reference/#Pigeons.Replica"><code>Replica</code></a>&#39;s state is modified using a <span>$\pi_i$</span>-invariant kernel,  where <span>$i$</span> is given by <code>Replica.chain</code>. Often, <code>Replica.chain</code> corresponds to  an annealing parameter <span>$\beta_i$</span> but this need not be the case (see  e.g. <a href="https://arxiv.org/abs/1108.3423">Baragatti et al., 2011</a>). The kernel can either modify <code>Replica.state</code> in-place, or modify the  <code>Replica</code>&#39;s <code>state</code> field. The key interface controlling local exploration, <a href="../interfaces/#Pigeons.explorer"><code>explorer</code></a>, is  described in more detail below. </p><h3 id="Communication"><a class="docs-heading-anchor" href="#Communication">Communication</a><a id="Communication-1"></a><a class="docs-heading-anchor-permalink" href="#Communication" title="Permalink"></a></h3><p>In the <strong>communication phase</strong>, PT proposes swaps between pairs of replicas.  These swaps allow each replica&#39;s state to periodically visit reference chains. During these reference visits, the state can move around the space quickly.  In principle, there are two equivalent ways to do a swap: the <code>Replica</code>s could exchange  their <code>state</code> fields; or alternatively, they could exchange their <code>chain</code> fields. Since we provide distributed implementations, we use the latter as it ensures that  the amount of data that needs to be exchanged between two machines during a swap  can be made very small (two floats).  It is remarkable that this cost does not vary with the dimensionality of the state space,  in constrast to the naive implementation which would transmit states over the network. See <a href="distributed.html">Distributed PT</a> for more information on our distributed implementation.</p><p>Both in distributed and single process mode,  swaps are performed using the function <a href="../reference/#Pigeons.swap!-Tuple{Any, Any, Any}"><code>swap!()</code></a>. </p><p>The key interface controlling communication, <a href="../interfaces/#Pigeons.tempering"><code>tempering</code></a>, is  described in more detail below. </p><h2 id="A-tour-of-the-PT-meta-algorithm"><a class="docs-heading-anchor" href="#A-tour-of-the-PT-meta-algorithm">A tour of the PT meta-algorithm</a><a id="A-tour-of-the-PT-meta-algorithm-1"></a><a class="docs-heading-anchor-permalink" href="#A-tour-of-the-PT-meta-algorithm" title="Permalink"></a></h2><p>A generalized version of Algorithm 1 (&quot;one round of PT&quot;) in <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al., 2021</a>  is implemented in Pigeons in <a href="../reference/#Pigeons.run_one_round!-Tuple{Any}"><code>run_one_round!()</code></a>,  while the complete algorithm (&quot;several adaptive rounds&quot;),  <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Algorithm 4 of Syed et al., 2021</a>,  has a generalized implementation in <a href="../reference/#Pigeons.pigeons-Tuple{}"><code>pigeons()</code></a>. </p><p>In the following we discuss different facets of these (meta-)algorithms.</p><h3 id="Storage-in-PT-algorithms"><a class="docs-heading-anchor" href="#Storage-in-PT-algorithms">Storage in PT algorithms</a><a id="Storage-in-PT-algorithms-1"></a><a class="docs-heading-anchor-permalink" href="#Storage-in-PT-algorithms" title="Permalink"></a></h3><p>The information stored in the execution of <a href="../reference/#Pigeons.pigeons-Tuple{}"><code>pigeons()</code></a>  is grouped in the struct <a href="../reference/#Pigeons.PT"><code>PT</code></a>.  The key fields are one pointing to a <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a> and  one to a <a href="../reference/#Pigeons.Shared"><code>Shared</code></a>.  Briefly, <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a> will store information distinct in each  MPI process, and read-write during each  round, while <a href="../reference/#Pigeons.Shared"><code>Shared</code></a> is identical in all MPI processes, read only during a round, and updated only between  rounds. </p><p>To orchestrate the creation of <a href="../reference/#Pigeons.PT"><code>PT</code></a> structs, <a href="../reference/#Pigeons.Inputs"><code>Inputs</code></a> is used. Inputs fully determines the execution of a  PT algorithm (target distribution, random seed, etc). </p><h3 id="Collecting-statistics:-[recorder](@ref)-and-[recorders](@ref)"><a class="docs-heading-anchor" href="#Collecting-statistics:-[recorder](@ref)-and-[recorders](@ref)">Collecting statistics: <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a> and <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a></a><a id="Collecting-statistics:-[recorder](@ref)-and-[recorders](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Collecting-statistics:-[recorder](@ref)-and-[recorders](@ref)" title="Permalink"></a></h3><p>Two steps are needed to collect statistics from the execution of a PT algorithm: </p><ul><li>Specifying which statistics to collect using one or several <a href="../interfaces/#Pigeons.recorder_builder"><code>recorder_builder</code></a>    (e.g. by    default, only some statistics that can be computed in constant memory  are included,    those that have growing memory consumption, e.g. tracking the full    index process as done here, need to be explicitly specified in advance).</li><li>Then at the end of <a href="../reference/#Pigeons.run_one_round!-Tuple{Any}"><code>run_one_round!()</code></a>, <a href="../reference/#Pigeons.reduce_recorders!-Tuple{Pigeons.EntangledReplicas}"><code>reduce_recorders!()</code></a>   is called to compile the statistics collected  by the different replicas.</li></ul><p>An object responsible for accumulating all different types of statistics for  one replica is called a  <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a>. An object accumulating one  type of statistic for one replica is a <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a>.  Each replica has a single recorders to ensure thread safety (e.g., see  the use of a parallel local exploration phase using <code>@thread</code> in <a href="../reference/#Pigeons.explore!-Tuple{Any, Any, Val{false}}"><code>explore!()</code></a>) and to enable distributed  computing. </p><h4 id="Using-a-built-in-[recorder](@ref)"><a class="docs-heading-anchor" href="#Using-a-built-in-[recorder](@ref)">Using a built-in <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a></a><a id="Using-a-built-in-[recorder](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Using-a-built-in-[recorder](@ref)" title="Permalink"></a></h4><p>To see the list of built-in implementations of <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a>, see the section &quot;Examples of functions..&quot; at <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a>. </p><p>To specify you want to use one <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a>, specify it in the Vector  argument <code>recorder_builders</code> in <a href="../reference/#Pigeons.Inputs"><code>Inputs</code></a>. For example, to signal you want  to save the full index process, use:</p><pre><code class="language-julia hljs">using Pigeons

pt = pigeons(target = toy_mvn_target(1), recorder_builders = [index_process])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">PT(&quot;/home/runner/work/Pigeons.jl/Pigeons.jl/docs/build/results/all/2023-01-14-21-54-19-1kzY0LW3&quot;)</code></pre><p>You can then access the index process via </p><pre><code class="language-julia hljs">pt.reduced_recorders.index_process</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">Dict{Int64, Vector{Int64}} with 10 entries:
  5  =&gt; [8, 7, 6, 5, 4, 3, 2, 1, 1, 2  …  5, 6, 6, 5, 5, 6, 7, 8, 9, 10]
  4  =&gt; [5, 6, 7, 8, 9, 10, 10, 9, 8, 7  …  6, 5, 4, 3, 2, 1, 1, 2, 3, 4]
  6  =&gt; [10, 9, 8, 7, 6, 5, 4, 3, 2, 1  …  8, 7, 7, 8, 9, 10, 10, 9, 8, 7]
  7  =&gt; [4, 3, 2, 1, 1, 2, 3, 4, 5, 6  …  9, 10, 10, 9, 8, 7, 6, 5, 4, 3]
  2  =&gt; [3, 4, 5, 6, 7, 8, 9, 10, 10, 9  …  7, 8, 9, 10, 10, 9, 8, 7, 6, 5]
  10 =&gt; [2, 2, 3, 4, 5, 6, 7, 8, 9, 10  …  4, 3, 2, 1, 1, 2, 3, 4, 5, 6]
  9  =&gt; [9, 10, 10, 9, 8, 7, 6, 5, 4, 3  …  10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
  8  =&gt; [1, 1, 1, 2, 3, 4, 5, 6, 7, 8  …  1, 1, 1, 2, 3, 4, 5, 6, 7, 8]
  3  =&gt; [6, 5, 4, 3, 2, 1, 1, 2, 3, 4  …  3, 4, 5, 6, 7, 8, 9, 10, 10, 9]
  1  =&gt; [7, 8, 9, 10, 10, 9, 8, 7, 6, 5  …  2, 2, 3, 4, 4, 3, 2, 1, 1, 2]</code></pre><h4 id="Creating-your-own-[recorder](@ref)"><a class="docs-heading-anchor" href="#Creating-your-own-[recorder](@ref)">Creating your own <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a></a><a id="Creating-your-own-[recorder](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Creating-your-own-[recorder](@ref)" title="Permalink"></a></h4><p>The following pieces are needed</p><ol><li>Pick or create a struct <code>MyStruct</code> that will hold the information. </li><li>Implement all the methods in the section &quot;Contract&quot; of <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a> making sure to type the recorder argument as <code>recorder::MyStruct</code>. Some examples are in the same source file as <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a> and/or in the same folder as <code>recorder.jl</code>.   </li><li>Create a <a href="../interfaces/#Pigeons.recorder_builder"><code>recorder_builder</code></a> which is simply a function such </li></ol><p>that when called with zero argument, creates your desired type, i.e.  <code>MyStruct</code>. The name of this function will define the name of your <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a>.</p><h3 id="Local-[explorer](@ref)"><a class="docs-heading-anchor" href="#Local-[explorer](@ref)">Local <a href="../interfaces/#Pigeons.explorer"><code>explorer</code></a></a><a id="Local-[explorer](@ref)-1"></a><a class="docs-heading-anchor-permalink" href="#Local-[explorer](@ref)" title="Permalink"></a></h3><p>Typical target distributions are expected to take care of building  their own explorers, so most users are not expected to have to  write their own. But for non-standard target it is useful to be  able to do so. </p><p>Building a new explorer is done as follows: first, suppose you are planning to use a non-standard target of type <code>MyTargetType</code></p><ol><li>Pick or create a struct <code>MyExplorerStruct</code> that may contain adaptation   information such as step sizes for HMC or proposal bandwidth.   Note that explorers will need to explore not only the target   distribution <span>$\pi$</span> but also the intermediate ones <span>$\pi_i$</span>.</li><li>Implement all the methods in the section &quot;Contract&quot; of <a href="../interfaces/#Pigeons.explorer"><code>explorer</code></a> making sure to type the explorer argument as <code>explorer::MyExplorerStruct</code>. Some examples are in the same folder as the source file of <a href="../interfaces/#Pigeons.explorer"><code>explorer</code></a>.  </li><li>Define a method <code>create_explorer(target::MyTargetType, inputs)</code> which   should return a fresh <code>MyExplorerStruct</code> instance. </li></ol><p>One explorer struct will be shared by all threads, so it should be  read-only during execution of <code>run_one_round!()</code>.  It can be adapted between rounds. </p><h3 id="Tempering"><a class="docs-heading-anchor" href="#Tempering">Tempering</a><a id="Tempering-1"></a><a class="docs-heading-anchor-permalink" href="#Tempering" title="Permalink"></a></h3><p>Customizing <a href="../reference/#Pigeons.communicate!-Tuple{Any}"><code>communicate!()</code></a> follows the same general steps as custom explorers, i.e.:</p><ol><li>Pick or create a struct <code>MyTemperingStruct</code> that may contain adaptation   information such as schedule optimization. </li><li>Implement all the methods in the section &quot;Contract&quot; of <a href="../interfaces/#Pigeons.tempering"><code>tempering</code></a> making sure to type the tempering argument as <code>tempering::MyTemperingStruct</code>. For example, see <a href="../reference/#Pigeons.NonReversiblePT"><code>NonReversiblePT</code></a>. </li><li>Initial construction of the tempering is done via  <a href="../reference/#Pigeons.create_tempering-Tuple{Inputs}"><code>create_tempering()</code></a>.</li></ol></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">« Guide</a><a class="docs-footer-nextpage" href="../distributed/">Distributed PT »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Saturday 14 January 2023 21:54">Saturday 14 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
