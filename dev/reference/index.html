<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Pigeons.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Julia-Tempering.github.io/Pigeons.jl/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Pigeons.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Guide</a></li><li><a class="tocitem" href="../pt/">Parallel Tempering (PT)</a></li><li><a class="tocitem" href="../distributed/">Distributed PT</a></li><li><a class="tocitem" href="../interfaces/">Interfaces</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Types-and-functions"><span>Types and functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/main/docs/src/reference.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="../interfaces/#Pigeons.explorer"><code>Pigeons.explorer</code></a></li><li><a href="../interfaces/#Pigeons.log_potential"><code>Pigeons.log_potential</code></a></li><li><a href="../interfaces/#Pigeons.log_potentials"><code>Pigeons.log_potentials</code></a></li><li><a href="../interfaces/#Pigeons.pair_swapper"><code>Pigeons.pair_swapper</code></a></li><li><a href="../interfaces/#Pigeons.path"><code>Pigeons.path</code></a></li><li><a href="../interfaces/#Pigeons.recorder"><code>Pigeons.recorder</code></a></li><li><a href="../interfaces/#Pigeons.recorder_builder"><code>Pigeons.recorder_builder</code></a></li><li><a href="../interfaces/#Pigeons.recorders"><code>Pigeons.recorders</code></a></li><li><a href="../interfaces/#Pigeons.replicas"><code>Pigeons.replicas</code></a></li><li><a href="../interfaces/#Pigeons.state_initializer"><code>Pigeons.state_initializer</code></a></li><li><a href="../interfaces/#Pigeons.swap_graph"><code>Pigeons.swap_graph</code></a></li><li><a href="../interfaces/#Pigeons.swap_graphs"><code>Pigeons.swap_graphs</code></a></li><li><a href="../interfaces/#Pigeons.target"><code>Pigeons.target</code></a></li><li><a href="../interfaces/#Pigeons.tempering"><code>Pigeons.tempering</code></a></li><li><a href="#Pigeons.ChildProcess"><code>Pigeons.ChildProcess</code></a></li><li><a href="#Pigeons.EntangledReplicas"><code>Pigeons.EntangledReplicas</code></a></li><li><a href="#Pigeons.Entangler"><code>Pigeons.Entangler</code></a></li><li><a href="#Pigeons.FromCheckpoint"><code>Pigeons.FromCheckpoint</code></a></li><li><a href="#Pigeons.Immutable-Tuple{Any}"><code>Pigeons.Immutable</code></a></li><li><a href="#Pigeons.Indexer-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>Pigeons.Indexer</code></a></li><li><a href="#Pigeons.Indexer"><code>Pigeons.Indexer</code></a></li><li><a href="#Pigeons.Inputs"><code>Pigeons.Inputs</code></a></li><li><a href="#Pigeons.InterpolatedLogPotential"><code>Pigeons.InterpolatedLogPotential</code></a></li><li><a href="#Pigeons.InterpolatingPath-Tuple{Any, Any}"><code>Pigeons.InterpolatingPath</code></a></li><li><a href="#Pigeons.Iterators"><code>Pigeons.Iterators</code></a></li><li><a href="#Pigeons.LoadBalance"><code>Pigeons.LoadBalance</code></a></li><li><a href="#Pigeons.MPI"><code>Pigeons.MPI</code></a></li><li><a href="#Pigeons.MPISettings"><code>Pigeons.MPISettings</code></a></li><li><a href="#Pigeons.NonReversiblePT-Tuple{Inputs}"><code>Pigeons.NonReversiblePT</code></a></li><li><a href="#Pigeons.NonReversiblePT"><code>Pigeons.NonReversiblePT</code></a></li><li><a href="#Pigeons.PT-Tuple{Inputs}"><code>Pigeons.PT</code></a></li><li><a href="#Pigeons.PT"><code>Pigeons.PT</code></a></li><li><a href="#Pigeons.PT-Tuple{AbstractString}"><code>Pigeons.PT</code></a></li><li><a href="#Pigeons.PermutedDistributedArray"><code>Pigeons.PermutedDistributedArray</code></a></li><li><a href="#Pigeons.Replica"><code>Pigeons.Replica</code></a></li><li><a href="#Pigeons.Reproducibility"><code>Pigeons.Reproducibility</code></a></li><li><a href="#Pigeons.Result"><code>Pigeons.Result</code></a></li><li><a href="#Pigeons.ScaledPrecisionNormalPath-Tuple{Int64}"><code>Pigeons.ScaledPrecisionNormalPath</code></a></li><li><a href="#Pigeons.ScaledPrecisionNormalPath"><code>Pigeons.ScaledPrecisionNormalPath</code></a></li><li><a href="#Pigeons.Schedule"><code>Pigeons.Schedule</code></a></li><li><a href="#Pigeons.Shared-Tuple{Any}"><code>Pigeons.Shared</code></a></li><li><a href="#Pigeons.Shared"><code>Pigeons.Shared</code></a></li><li><a href="#Pigeons.SliceSampler"><code>Pigeons.SliceSampler</code></a></li><li><a href="#Pigeons.Submission"><code>Pigeons.Submission</code></a></li><li><a href="#Pigeons.SwapStat"><code>Pigeons.SwapStat</code></a></li><li><a href="#Pigeons.TestSwapper"><code>Pigeons.TestSwapper</code></a></li><li><a href="#Pigeons.ThisProcess"><code>Pigeons.ThisProcess</code></a></li><li><a href="#Pigeons.ToyExplorer"><code>Pigeons.ToyExplorer</code></a></li><li><a href="#Pigeons.TuringLogPotential-Tuple{DynamicPPL.Model}"><code>Pigeons.TuringLogPotential</code></a></li><li><a href="#Pigeons.NRPT-Tuple{Any, Any, Array{Vector{T}, 1} where T&lt;:Real, Int64, Int64}"><code>Pigeons.NRPT</code></a></li><li><a href="#Pigeons.acceptanceprobability-Tuple{Any, Any, Any}"><code>Pigeons.acceptanceprobability</code></a></li><li><a href="#Pigeons.adapt-Tuple{Any, Any}"><code>Pigeons.adapt</code></a></li><li><a href="#Pigeons.adapt_explorer-Tuple{Any, Any, Any}"><code>Pigeons.adapt_explorer</code></a></li><li><a href="#Pigeons.adapt_tempering-Tuple{Any, Any}"><code>Pigeons.adapt_tempering</code></a></li><li><a href="#Pigeons.adapted_schedule-Tuple{Int64, Any}"><code>Pigeons.adapted_schedule</code></a></li><li><a href="#Pigeons.all_reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Pigeons.Entangler}} where T"><code>Pigeons.all_reduce_deterministically</code></a></li><li><a href="#Pigeons.analytic_cumulativebarrier-Tuple{Pigeons.ScaledPrecisionNormalPath}"><code>Pigeons.analytic_cumulativebarrier</code></a></li><li><a href="#Pigeons.check_against_serial-Tuple{Any}"><code>Pigeons.check_against_serial</code></a></li><li><a href="#Pigeons.checksum"><code>Pigeons.checksum</code></a></li><li><a href="#Pigeons.communicate!-Tuple{Any}"><code>Pigeons.communicate!</code></a></li><li><a href="#Pigeons.communicationbarrier-Tuple{AbstractVector, AbstractVector}"><code>Pigeons.communicationbarrier</code></a></li><li><a href="#Pigeons.communicator-Tuple{Any}"><code>Pigeons.communicator</code></a></li><li><a href="#Pigeons.computeetas-Tuple{Any, Any}"><code>Pigeons.computeetas</code></a></li><li><a href="#Pigeons.create_entangled_replicas-Tuple{Inputs, Pigeons.Shared, Any}"><code>Pigeons.create_entangled_replicas</code></a></li><li><a href="#Pigeons.create_explorer-Tuple{Any, Any}"><code>Pigeons.create_explorer</code></a></li><li><a href="#Pigeons.create_explorer-Tuple{Any, Inputs}"><code>Pigeons.create_explorer</code></a></li><li><a href="#Pigeons.create_explorer-Tuple{Any}"><code>Pigeons.create_explorer</code></a></li><li><a href="#Pigeons.create_pair_swapper-Tuple{Any, Any}"><code>Pigeons.create_pair_swapper</code></a></li><li><a href="#Pigeons.create_path-Tuple{Any, Inputs}"><code>Pigeons.create_path</code></a></li><li><a href="#Pigeons.create_path-Tuple{Pigeons.ScaledPrecisionNormalPath, Inputs}"><code>Pigeons.create_path</code></a></li><li><a href="#Pigeons.create_recorders-Tuple{Any}"><code>Pigeons.create_recorders</code></a></li><li><a href="#Pigeons.create_recorders-Tuple{Inputs, Pigeons.Shared}"><code>Pigeons.create_recorders</code></a></li><li><a href="#Pigeons.create_reference_log_potential-Tuple{Any, Inputs}"><code>Pigeons.create_reference_log_potential</code></a></li><li><a href="#Pigeons.create_replicas-Tuple{Inputs, Pigeons.Shared, Any}"><code>Pigeons.create_replicas</code></a></li><li><a href="#Pigeons.create_state_initializer-Tuple{Any, Inputs}"><code>Pigeons.create_state_initializer</code></a></li><li><a href="#Pigeons.create_swap_graph-Tuple{Any, Any}"><code>Pigeons.create_swap_graph</code></a></li><li><a href="#Pigeons.create_tempering-Tuple{Inputs}"><code>Pigeons.create_tempering</code></a></li><li><a href="#Pigeons.create_vector_replicas-Tuple{Inputs, Pigeons.Shared, Any}"><code>Pigeons.create_vector_replicas</code></a></li><li><a href="#Pigeons.deo-Tuple{Any}"><code>Pigeons.deo</code></a></li><li><a href="#Pigeons.deo-Tuple{Any, Any, Any, Any, Any, Any, Int64, Int64, Int64, Any, Any, Any, Any, Bool, Any, Int64}"><code>Pigeons.deo</code></a></li><li><a href="#Pigeons.deoscan-NTuple{15, Any}"><code>Pigeons.deoscan</code></a></li><li><a href="#Pigeons.deserialize_immutables-Tuple{AbstractString}"><code>Pigeons.deserialize_immutables</code></a></li><li><a href="#Pigeons.discretize-Tuple{Any, Pigeons.Schedule}"><code>Pigeons.discretize</code></a></li><li><a href="#Pigeons.entangler-Tuple{Any}"><code>Pigeons.entangler</code></a></li><li><a href="#Pigeons.equally_spaced_schedule-Tuple{Int64}"><code>Pigeons.equally_spaced_schedule</code></a></li><li><a href="#Pigeons.explore!-Tuple{Any, Any, Val{true}}"><code>Pigeons.explore!</code></a></li><li><a href="#Pigeons.explore!-Tuple{Any, Any, Val{false}}"><code>Pigeons.explore!</code></a></li><li><a href="#Pigeons.explorer_recorder_builders-Tuple{Any}"><code>Pigeons.explorer_recorder_builders</code></a></li><li><a href="#Pigeons.find_global_index-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_global_index</code></a></li><li><a href="#Pigeons.find_local_index-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_local_index</code></a></li><li><a href="#Pigeons.find_log_potential-Tuple{Any, Any}"><code>Pigeons.find_log_potential</code></a></li><li><a href="#Pigeons.find_process-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_process</code></a></li><li><a href="#Pigeons.flush_immutables!-Tuple{}"><code>Pigeons.flush_immutables!</code></a></li><li><a href="#Pigeons.index_process-Tuple{}"><code>Pigeons.index_process</code></a></li><li><a href="#Pigeons.index_process_plot-Tuple{Any}"><code>Pigeons.index_process_plot</code></a></li><li><a href="#Pigeons.informal_doc-Tuple{Any, Module}"><code>Pigeons.informal_doc</code></a></li><li><a href="#Pigeons.initialization-Tuple{Any, SplittableRandoms.SplittableRandom, Int64}"><code>Pigeons.initialization</code></a></li><li><a href="#Pigeons.interpolate-Tuple{Any, Any}"><code>Pigeons.interpolate</code></a></li><li><a href="#Pigeons.is_finished-Tuple{AbstractString, Any}"><code>Pigeons.is_finished</code></a></li><li><a href="#Pigeons.latest_checkpoint_folder-Tuple{Any}"><code>Pigeons.latest_checkpoint_folder</code></a></li><li><a href="#Pigeons.load-Union{Tuple{Result{T}}, Tuple{T}} where T"><code>Pigeons.load</code></a></li><li><a href="#Pigeons.load-Tuple{Any}"><code>Pigeons.load</code></a></li><li><a href="#Pigeons.local_exploration-NTuple{9, Any}"><code>Pigeons.local_exploration</code></a></li><li><a href="#Pigeons.locals-Tuple{Any}"><code>Pigeons.locals</code></a></li><li><a href="#Pigeons.log_unnormalized_ratio-Tuple{AbstractVector, Int64, Int64, Any}"><code>Pigeons.log_unnormalized_ratio</code></a></li><li><a href="#Pigeons.log_unnormalized_ratio-Tuple{Any, Int64, Int64, Any}"><code>Pigeons.log_unnormalized_ratio</code></a></li><li><a href="#Pigeons.lognormalizingconstant-Tuple{Any, Any}"><code>Pigeons.lognormalizingconstant</code></a></li><li><a href="#Pigeons.mpi_active-Tuple{}"><code>Pigeons.mpi_active</code></a></li><li><a href="#Pigeons.my_global_indices-Tuple{Pigeons.LoadBalance}"><code>Pigeons.my_global_indices</code></a></li><li><a href="#Pigeons.my_load-Tuple{Pigeons.LoadBalance}"><code>Pigeons.my_load</code></a></li><li><a href="#Pigeons.n_chains-Tuple{Any}"><code>Pigeons.n_chains</code></a></li><li><a href="#Pigeons.next_exec_folder-Tuple{}"><code>Pigeons.next_exec_folder</code></a></li><li><a href="#Pigeons.one_per_host-Tuple{Any}"><code>Pigeons.one_per_host</code></a></li><li><a href="#Pigeons.only_one_process-Tuple{Any, Any}"><code>Pigeons.only_one_process</code></a></li><li><a href="#Pigeons.partner_chain-Tuple{Any, Int64}"><code>Pigeons.partner_chain</code></a></li><li><a href="#Pigeons.permuted_get-Union{Tuple{T}, Tuple{Pigeons.PermutedDistributedArray{T}, AbstractVector{Int64}}} where T"><code>Pigeons.permuted_get</code></a></li><li><a href="#Pigeons.permuted_set!-Union{Tuple{T}, Tuple{Pigeons.PermutedDistributedArray{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>Pigeons.permuted_set!</code></a></li><li><a href="#Pigeons.pigeons-Tuple{Any}"><code>Pigeons.pigeons</code></a></li><li><a href="#Pigeons.pigeons-Tuple{Any, ChildProcess}"><code>Pigeons.pigeons</code></a></li><li><a href="#Pigeons.pigeons-Tuple{Any, MPI}"><code>Pigeons.pigeons</code></a></li><li><a href="#Pigeons.pigeons-Tuple{PT}"><code>Pigeons.pigeons</code></a></li><li><a href="#Pigeons.pigeons-Tuple{}"><code>Pigeons.pigeons</code></a></li><li><a href="#Pigeons.providers-Tuple{Module, Symbol}"><code>Pigeons.providers</code></a></li><li><a href="#Pigeons.record!-Tuple{OnlineStatsBase.OnlineStat, Any}"><code>Pigeons.record!</code></a></li><li><a href="#Pigeons.record!-Tuple{Any, Any}"><code>Pigeons.record!</code></a></li><li><a href="#Pigeons.record!-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K, Vector{V}}, Tuple{K, V}}} where {K, V}"><code>Pigeons.record!</code></a></li><li><a href="#Pigeons.record_if_requested!-Tuple{Any, Symbol, Any}"><code>Pigeons.record_if_requested!</code></a></li><li><a href="#Pigeons.record_swap_stats!-Tuple{Any, Any, Int64, Any, Int64, Any}"><code>Pigeons.record_swap_stats!</code></a></li><li><a href="#Pigeons.record_swap_stats!-Tuple{Pigeons.TestSwapper, Any, Int64, Any, Int64, Any}"><code>Pigeons.record_swap_stats!</code></a></li><li><a href="#Pigeons.reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Pigeons.Entangler}} where T"><code>Pigeons.reduce_deterministically</code></a></li><li><a href="#Pigeons.reduce_recorders!-Tuple{Pigeons.EntangledReplicas}"><code>Pigeons.reduce_recorders!</code></a></li><li><a href="#Pigeons.reference_chains-Tuple{Any, Any}"><code>Pigeons.reference_chains</code></a></li><li><a href="#Pigeons.report-Tuple{Any, Any}"><code>Pigeons.report</code></a></li><li><a href="#Pigeons.restarts-Tuple{Any}"><code>Pigeons.restarts</code></a></li><li><a href="#Pigeons.roundtrip-Tuple{Any}"><code>Pigeons.roundtrip</code></a></li><li><a href="#Pigeons.run_checks-Tuple{Any}"><code>Pigeons.run_checks</code></a></li><li><a href="#Pigeons.run_one_round!-Tuple{Any}"><code>Pigeons.run_one_round!</code></a></li><li><a href="#Pigeons.sample_iid!-Tuple{Any, Any}"><code>Pigeons.sample_iid!</code></a></li><li><a href="#Pigeons.serialize_immutables-Tuple{AbstractString}"><code>Pigeons.serialize_immutables</code></a></li><li><a href="#Pigeons.setkernels-Tuple{Any, Any}"><code>Pigeons.setkernels</code></a></li><li><a href="#Pigeons.setup_mpi-Tuple{Pigeons.MPISettings}"><code>Pigeons.setup_mpi</code></a></li><li><a href="#Pigeons.setup_mpi-Tuple{}"><code>Pigeons.setup_mpi</code></a></li><li><a href="#Pigeons.single_process_load-Tuple{Any}"><code>Pigeons.single_process_load</code></a></li><li><a href="#Pigeons.slice_accept-Tuple{Pigeons.SliceSampler, Any, Any, Any, Any, Any, Any, Any}"><code>Pigeons.slice_accept</code></a></li><li><a href="#Pigeons.slice_double-Tuple{Pigeons.SliceSampler, Any, Any, Any, Any, Any}"><code>Pigeons.slice_double</code></a></li><li><a href="#Pigeons.slice_sample!-Tuple{Pigeons.SliceSampler, AbstractVector, Any, Any}"><code>Pigeons.slice_sample!</code></a></li><li><a href="#Pigeons.slice_shrink-Tuple{Pigeons.SliceSampler, Any, Any, Any, Any, Any, Any, Any}"><code>Pigeons.slice_shrink</code></a></li><li><a href="#Pigeons.sort_includes!-Tuple{Any}"><code>Pigeons.sort_includes!</code></a></li><li><a href="#Pigeons.split_slice-Tuple{UnitRange, Any}"><code>Pigeons.split_slice</code></a></li><li><a href="#Pigeons.step!-Tuple{Any, Any, Any}"><code>Pigeons.step!</code></a></li><li><a href="#Pigeons.swap!-Union{Tuple{R}, Tuple{Any, Vector{R}, Any}} where R"><code>Pigeons.swap!</code></a></li><li><a href="#Pigeons.swap!-Tuple{Any, Pigeons.EntangledReplicas, Any}"><code>Pigeons.swap!</code></a></li><li><a href="#Pigeons.swap!-Tuple{Any, Any, Any}"><code>Pigeons.swap!</code></a></li><li><a href="#Pigeons.swap_acceptance_pr-Tuple{}"><code>Pigeons.swap_acceptance_pr</code></a></li><li><a href="#Pigeons.swap_decision-Tuple{Any, Int64, Any, Int64, Any}"><code>Pigeons.swap_decision</code></a></li><li><a href="#Pigeons.swap_decision-Tuple{Pigeons.TestSwapper, Int64, Float64, Int64, Float64}"><code>Pigeons.swap_decision</code></a></li><li><a href="#Pigeons.swap_stat-Tuple{Any, Pigeons.Replica, Int64}"><code>Pigeons.swap_stat</code></a></li><li><a href="#Pigeons.swap_stat-Tuple{Pigeons.TestSwapper, Pigeons.Replica, Int64}"><code>Pigeons.swap_stat</code></a></li><li><a href="#Pigeons.target_chains-Tuple{Any, Any}"><code>Pigeons.target_chains</code></a></li><li><a href="#Pigeons.tempering_recorder_builders-Tuple{Any}"><code>Pigeons.tempering_recorder_builders</code></a></li><li><a href="#Pigeons.toy_mvn_target-Tuple{Int64}"><code>Pigeons.toy_mvn_target</code></a></li><li><a href="#Pigeons.transmit-Union{Tuple{T}, Tuple{Pigeons.Entangler, AbstractVector{T}, AbstractVector{Int64}}} where T"><code>Pigeons.transmit</code></a></li><li><a href="#Pigeons.transmit!-Union{Tuple{T}, Tuple{Pigeons.Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T"><code>Pigeons.transmit!</code></a></li><li><a href="#Pigeons.updateschedule-Tuple{Any, Int64}"><code>Pigeons.updateschedule</code></a></li><li><a href="#Pigeons.winsorized_mean-Tuple{Any}"><code>Pigeons.winsorized_mean</code></a></li><li><a href="#Pigeons.winsorized_std-Tuple{Any}"><code>Pigeons.winsorized_std</code></a></li><li><a href="#Pigeons.write_checkpoint-Tuple{Any, Any}"><code>Pigeons.write_checkpoint</code></a></li><li><a href="#Pigeons.@abstract-Tuple{}"><code>Pigeons.@abstract</code></a></li><li><a href="#Pigeons.@informal-Tuple{Symbol, Expr}"><code>Pigeons.@informal</code></a></li><li><a href="#Pigeons.@weighted-Tuple{Any, Any}"><code>Pigeons.@weighted</code></a></li></ul><h2 id="Types-and-functions"><a class="docs-heading-anchor" href="#Types-and-functions">Types and functions</a><a id="Types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Pigeons.ChildProcess" href="#Pigeons.ChildProcess"><code>Pigeons.ChildProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Flag to run to a new julia  process. Useful e.g. to dynamically control  the number of threads to use.   Fields: </p><ul><li><code>n_threads</code>: The number of threads to provide in the child julia process, the same as the current process by default.</li></ul><ul><li><code>extra_julia_modules</code>: Extra Julia <code>Module</code>s needed by the child process.</li></ul><ul><li><code>n_local_mpi_processes</code>: If greater than one, run the code locally over MPI using that many MPI processes. In most cases, this is useful only for debugging purpose, as multi-threading should typically perform better. This could also potentially be useful if using a third-party target distribution which somehow does not support multi-threading.</li></ul><ul><li><code>wait</code>: If wait is false, the process runs asynchronously. When wait is false, the process&#39; I/O streams are directed to devnull.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/ChildProcess.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.EntangledReplicas" href="#Pigeons.EntangledReplicas"><code>Pigeons.EntangledReplicas</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An implementation of <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a> for distributed PT.  Contains:</p><ul><li><code>locals</code>: The subset of replicas hosted in this process</li></ul><ul><li><code>chain_to_replica_global_indices</code>: A specialized distributed array that maps chain indices to replica indices (global indices). This corresponds to the mapping <span>$\boldsymbol{j}$</span> in line 2 of Algorithm 5 in <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al, 2021</a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/EntangledReplicas.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Entangler" href="#Pigeons.Entangler"><code>Pigeons.Entangler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Assume all the MPI processes linked by this communicator  will all call the <em>key operations</em> listed below the same number of times  in their lifetime, at logically related occasions (e.g. a set  number of times per iteration for algorithms running the  same number of iterations). We call these &#39;occasions&#39; a micro-iteration.</p><p>This datastructure keeps track internally of appropriate unique  tags to coordinate the communication between MPI processes  without having to do any explicit synchronization. </p><p>This struct contains:</p><ul><li><code>communicator</code>: An MPI <code>Comm</code> object (or nothing if a single process is involved).</li></ul><ul><li><code>load</code>: How a set of tasks or &quot;global indices&quot; are distributed across processes.</li></ul><ul><li><code>current_received_bits</code>: An internal datastructure used during MPI calls.</li></ul><ul><li><code>n_transmits</code>: The current micro-iteration.</li></ul><p>The <em>key operations</em> supported:</p><ul><li><a href="#Pigeons.transmit-Union{Tuple{T}, Tuple{Pigeons.Entangler, AbstractVector{T}, AbstractVector{Int64}}} where T"><code>transmit()</code></a> and <a href="#Pigeons.transmit!-Union{Tuple{T}, Tuple{Pigeons.Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T"><code>transmit!()</code></a>: encapsulates    pairwise communications in which each MPI process is holding     a <code>Vector</code>, the elements of which are to be permuted across the processes.</li><li><a href="#Pigeons.all_reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Pigeons.Entangler}} where T"><code>all_reduce_deterministically</code></a> and <a href="#Pigeons.reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Pigeons.Entangler}} where T"><code>reduce_deterministically</code></a>,    to perform MPI collective reduction while maintaining the    Parallelism Invariance property.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/Entangler.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.FromCheckpoint" href="#Pigeons.FromCheckpoint"><code>Pigeons.FromCheckpoint</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Flag <a href="#Pigeons.create_replicas-Tuple{Inputs, Pigeons.Shared, Any}"><code>create_replicas</code></a> (and related functions) that replicas  should be loaded from a checkpoint. Fields:</p><ul><li><code>checkpoint_folder</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/replicas.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Immutable-Tuple{Any}" href="#Pigeons.Immutable-Tuple{Any}"><code>Pigeons.Immutable</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Immutable(data)
</code></pre><p>Consider a situation where a distributed system serializes its state,   and part of the state contains large immutable data. When the distributed processes each independently call  <code>Serialization.serialize()</code>, naively the processes would each write identical  copies of the large immutable data, which is space-inefficient. </p><p><code>Immutable</code> resolves this space-inefficiency. For most users,  all they need to know is to enclose large data inside the  struct <code>Immutable</code>. </p><p>Details of how serialization/deserialization is performed:</p><ol><li>Enclose large immutable data inside a <code>Immutable</code>.   Assume the type of data has well defined hash and ==.  Internally, we maintain an internal, global Dict indexed   by hash(data) storing the data. This global Dict is   called <code>immutables</code>.</li><li>Use flush_immutable() to clear the global immutable state</li><li>Use <code>Serialization.serialize</code> as usual. Internally, we   dispatch serialization of <code>Immutable</code> is modified to skip   the field containing the data.</li><li>Make one of the processes call <a href="#Pigeons.serialize_immutables-Tuple{AbstractString}"><code>serialize_immutables()</code></a>.   This serializes the <code>immutables</code> Dict.</li><li>Then for de-serialization, each process should call   <a href="#Pigeons.deserialize_immutables-Tuple{AbstractString}"><code>deserialize_immutables()</code></a>. This restores   <code>immutable</code>.</li><li>Finally, call <code>Serialization.deserialize()</code> as usual.   When an <code>Immutable</code> instances is being deserialize, we   dispatch deserialization so that the data is retreived   from <code>immutable</code>.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/Immutable.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Indexer" href="#Pigeons.Indexer"><code>Pigeons.Indexer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A bijection between integers and some type <code>T</code>.  <code>T</code> is assumed to have consistent <code>hash</code> and <code>==</code>. The two sides of the bijection can be obtained with the fields:</p><ul><li><code>i2t</code>: A <code>Vector</code> mapping <strong>i</strong>ntegers to objects <strong>t</strong> of type <code>T</code>.</li></ul><ul><li><code>t2i</code>: A <code>Dict</code> mapping objects <strong>t</strong> of type <code>T</code> to <strong>i</strong>ntegers.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/Indexer.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Indexer-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T" href="#Pigeons.Indexer-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T"><code>Pigeons.Indexer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Indexer(i2t)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/Indexer.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Inputs" href="#Pigeons.Inputs"><code>Pigeons.Inputs</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <a href="https://github.com/JuliaLang/julia/blob/79ceb8dbeab1b5a47c6bd664214616c19607ffab/base/util.jl#L514"><code>Base.@kwdef</code></a> struct  used to create Parallel Tempering algorithms. </p><p>Fields (see source file for default values):</p><ul><li><p><code>target</code>:  The target distribution.</p></li><li><p><code>seed</code>:  The master random seed.</p></li><li><p><code>n_rounds</code>:  The number of rounds to run.</p></li><li><p><code>n_chains</code>:  The number of chains to use.</p></li><li><p><code>checkpoint</code>:  Whether a checkpoint should be written to disk at the end of each round.</p></li></ul><ul><li><code>recorder_builders</code>: An Vector with elements of type <a href="../interfaces/#Pigeons.recorder_builder"><code>recorder_builder</code></a>.</li></ul><ul><li><code>checked_round</code>: The round index where <a href="#Pigeons.run_checks-Tuple{Any}"><code>run_checks()</code></a> will be performed. Set to 0 to skip these checks.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/Inputs.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.InterpolatedLogPotential" href="#Pigeons.InterpolatedLogPotential"><code>Pigeons.InterpolatedLogPotential</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <a href="../interfaces/#Pigeons.log_potential"><code>log_potential</code></a> obtained by evaluation of a <a href="../interfaces/#Pigeons.path"><code>path</code></a> at a point beta. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/paths/InterpolatedLogPotential.jl#L1-L3">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.InterpolatingPath-Tuple{Any, Any}" href="#Pigeons.InterpolatingPath-Tuple{Any, Any}"><code>Pigeons.InterpolatingPath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">InterpolatingPath(ref, target)
</code></pre><p>Given a reference <a href="../interfaces/#Pigeons.log_potential"><code>log_potential</code></a> and a target <a href="../interfaces/#Pigeons.log_potential"><code>log_potential</code></a>,  return a <a href="../interfaces/#Pigeons.path"><code>path</code></a> interpolating between them. </p><p>By default, the <code>interpolator</code> is a <code>LinearInterpolator</code>, i.e.  standard annealing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/paths/InterpolatingPath.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Iterators" href="#Pigeons.Iterators"><code>Pigeons.Iterators</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Iterators used in Parallel Tempering. Stored in a struct so that  <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a>&#39;s can access it when outputting  sample statistics.</p><p>Fields:</p><ul><li><code>round</code>: Index of the Parallel Tempering adaptation <em>round</em>, as defined in <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Algorithm 4 of Syed et al., 2021</a>. Set to zero when when pigeons() not yet started.</li></ul><ul><li><code>scan</code>: Number of (exploration, communication) pairs performed so far, corresponds to <span>$n$</span> in <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Algorithm 1 of Syed et al., 2021</a>. Round <span>$i$</span> typically performs <span>$2^i$</span> scans. Set to zero when run<em>one</em>round!() is not yet started.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/Iterators.jl#L1-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.LoadBalance" href="#Pigeons.LoadBalance"><code>Pigeons.LoadBalance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Split a list of indices across processes.  These indices are denoted <span>$1, 2, .., N$</span>. They are usually some kind of task,  for example in the context of parallel tempering,  two kinds of tasks arise:</p><ul><li>in <code>replicas.state</code>, task <span>$i$</span> consists in keeping track of the state of    replica <span>$i$</span>.</li><li>in <code>replicas.chain_to_replica_global_indices</code>, task <span>$i$</span> consists in    storing which replica index corresponds to chain <span>$i$</span>.</li></ul><p>One such task index is called a <code>global_index</code>. </p><p>LoadBalance splits the global indices among <code>n_processes</code>. LoadBalance  is constructed so that the difference in the number of global indices  a process is responsible of (its &quot;load&quot;)  is at most one.</p><p>A <code>LoadBalance</code> contains:</p><ul><li><code>my_process_index</code>: A unique index for this process. We use 1-indexed, i.e. hide MPI&#39;s 0-indexed ranks.</li></ul><ul><li><code>n_processes</code>: Total number of processes involved.</li></ul><ul><li><code>n_global_indices</code>: The total number of global indices shared between all the processes.</li></ul><p>The set {1, 2, .., <a href="#Pigeons.load-Tuple{Any}"><code>load()</code></a>} is called a set of local indices.  A local index indexes a slice in {1, 2, ..., <code>n_global_indices</code>}.  Collectively over the <code>n_processes</code>, these slices form a partition of  the global indices.</p><p>Key functions to utilize a LoadBalance struct:</p><ul><li><a href="#Pigeons.my_global_indices-Tuple{Pigeons.LoadBalance}"><code>my_global_indices()</code></a></li><li><a href="#Pigeons.find_process-Tuple{Pigeons.LoadBalance, Int64}"><code>find_process()</code></a></li><li><a href="#Pigeons.find_local_index-Tuple{Pigeons.LoadBalance, Int64}"><code>find_local_index()</code></a></li><li><a href="#Pigeons.my_load-Tuple{Pigeons.LoadBalance}"><code>my_load()</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/LoadBalance.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.MPI" href="#Pigeons.MPI"><code>Pigeons.MPI</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Flag to run on MPI. Before using, you have to call once <a href="#Pigeons.setup_mpi-Tuple{Pigeons.MPISettings}"><code>setup_mpi</code></a>.</p><p>Fields: </p><ul><li><code>n_threads</code>: The number of threads per MPI process, 1 by default.</li></ul><ul><li><code>walltime</code>: The walltime limit, 00:30:00 by default (i.e., 30 minutes).</li></ul><ul><li><code>n_mpi_processes</code>: The number of MPI processes, 2 by default.</li></ul><ul><li><code>memory</code>: The memory allocated to each MPI process, 8gb by default.</li></ul><ul><li><code>extra_julia_modules</code>: Extra Julia <code>Module</code>s needed by the child process.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/MPI.jl#L9-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.MPISettings" href="#Pigeons.MPISettings"><code>Pigeons.MPISettings</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Global settings needed for MPI job submission:</p><ul><li><code>allocation_code</code>: E.g., for -A in PBS submission scripts.</li></ul><ul><li><code>environment_modules</code>: Run <code>module avail</code> in the terminal to see what is available on your HPC.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/MPISettings.jl#L2-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.NonReversiblePT" href="#Pigeons.NonReversiblePT"><code>Pigeons.NonReversiblePT</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Variables needed for the non-reversible Parallel Tempering described in  <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al., 2021</a>:</p><ul><li><p><code>path</code>:  The <a href="../interfaces/#Pigeons.path"><code>path</code></a>.</p></li><li><p><code>schedule</code>:  The <a href="#Pigeons.Schedule"><code>Schedule</code></a>.</p></li><li><p><code>log_potentials</code>:  The <a href="../interfaces/#Pigeons.log_potentials"><code>log_potentials</code></a>.</p></li><li><p><code>swap_graphs</code>:  The <a href="../interfaces/#Pigeons.swap_graphs"><code>swap_graphs</code></a>.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/tempering/NonReversiblePT.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.NonReversiblePT-Tuple{Inputs}" href="#Pigeons.NonReversiblePT-Tuple{Inputs}"><code>Pigeons.NonReversiblePT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NonReversiblePT(inputs)
</code></pre><p>The adaptive non-reversible Parallel Tempering described in  <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al., 2021</a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/tempering/NonReversiblePT.jl#L24-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.PT" href="#Pigeons.PT"><code>Pigeons.PT</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Storage involved in PT algorithms:</p><ul><li><code>inputs</code>: The user-provided <a href="#Pigeons.Inputs"><code>Inputs</code></a> that determine the execution of a PT algorithm.</li></ul><ul><li><code>replicas</code>: The <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a> held by this machine.</li></ul><ul><li><code>shared</code>: Information shared across all machines, updated between rounds.</li></ul><ul><li><code>exec_folder</code>: Either a path to a folder shared by all processes, which is used to save information to disk (checkpoints, samples etc); or nothing if a completely in-memory algorithm is used.</li></ul><ul><li><code>reduced_recorders</code>: <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a> from the last round, or empty <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/PT.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.PT-Tuple{AbstractString}" href="#Pigeons.PT-Tuple{AbstractString}"><code>Pigeons.PT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PT(source_exec_folder; round, fresh_exec_folder)
</code></pre><p>Create a <a href="#Pigeons.PT"><code>PT</code></a> struct from a saved  checkpoint. The path [<code>checkpoint_folder</code>]  should point to a folder with the name  <code>checkpoint</code> found under  <code>results/all/[exec_folder]/round=x</code>.</p><p>The checkpoint carries all the information stored in  a <a href="#Pigeons.PT"><code>PT</code></a> struct. It is possible for an MPI-based  execution to load a checkpoint written by a single-process  execution and vice versa.</p><p>A new unique folder will be created with symlinks to  the source one, so that e.g. running more rounds of  PT will results in a new space-efficient checkpoint  containing all the information for the new run.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/checkpoint.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.PT-Tuple{Inputs}" href="#Pigeons.PT-Tuple{Inputs}"><code>Pigeons.PT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">PT(inputs; exec_folder)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/PT.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.PermutedDistributedArray" href="#Pigeons.PermutedDistributedArray"><code>Pigeons.PermutedDistributedArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A distributed array making special assumptions on how  it will be accessed and written to.  The indices of this distributed array correspond to the  notion of &quot;global indices&quot; defined in <a href="#Pigeons.LoadBalance"><code>LoadBalance</code></a>.  Several MPI processes cooperate, each processing storing  data for a slice of this distributed array. </p><p>We make the following assumptions:</p><ul><li><p>Each MPI process will set/get    entries the same number of times in their lifetime, at    logically related episodes (e.g. a set    number of times per iteration for algorithms running the    same number of iterations).    These episodes are called micro-iterations as in <a href="#Pigeons.Entangler"><code>Entangler</code></a>,    which this datastructure is built on.</p></li><li><p>Moreover, at each time all processes perform a get or a set,    we assume that each global index is manipulated by exactly one    process (i.e. an implicit permutation of the global indices).</p></li></ul><p>We use these assumptions to achieve read/write costs that are  near-constant in the number of machines participating. </p><p>This struct contains:</p><ul><li><code>local_data</code>: The slice of the distributed array maintained by this MPI process.</li></ul><ul><li><code>entangler</code>: An <a href="#Pigeons.Entangler"><code>Entangler</code></a> used to coordinate communication.</li></ul><p>The operations supported are:</p><ul><li><a href="#Pigeons.permuted_get-Union{Tuple{T}, Tuple{Pigeons.PermutedDistributedArray{T}, AbstractVector{Int64}}} where T"><code>permuted_get()</code></a></li><li><a href="#Pigeons.permuted_set!-Union{Tuple{T}, Tuple{Pigeons.PermutedDistributedArray{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>permuted_set!()</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/PermutedDistributedArray.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Replica" href="#Pigeons.Replica"><code>Pigeons.Replica</code></a> — <span class="docstring-category">Type</span></header><section><div><p>One of the <span>$N$</span> components that forms the state maintained by a PT algorithm. A Replica contains:</p><ul><li><p><code>state</code>:  Configuration in the state space.</p></li><li><p><code>chain</code>:  The index of the distribution currently associated with this replica, modified during swaps.</p></li></ul><ul><li><code>rng</code>:  Random operations involving this state should use only this random number generator.</li></ul><ul><li><code>recorders</code>: Records statistics. Each replica carries its own for thread safety/distribution; then they are reduced at end of each round.</li></ul><ul><li><code>replica_index</code>: A global id associated with this replica.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/Replica.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Reproducibility" href="#Pigeons.Reproducibility"><code>Pigeons.Reproducibility</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Used to check reproducibility of jobs.   Less emphasis on speed, more on getting diagnostic when  reproducibility is violated.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/checks/Reproducibility.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Result" href="#Pigeons.Result"><code>Pigeons.Result</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A link to an execution folder able to  deserialize type T via a string constructor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/Result.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.ScaledPrecisionNormalPath" href="#Pigeons.ScaledPrecisionNormalPath"><code>Pigeons.ScaledPrecisionNormalPath</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <a href="../interfaces/#Pigeons.path"><code>path</code></a> of zero-mean normals for testing; contains:</p><ul><li><p><code>precision0</code>: Precision parameter of the reference.</p></li><li><p><code>precision1</code>: Precision parameter of the target.</p></li><li><p><code>dim</code>: Dimensionality.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/paths/ScaledPrecisionNormalPath.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.ScaledPrecisionNormalPath-Tuple{Int64}" href="#Pigeons.ScaledPrecisionNormalPath-Tuple{Int64}"><code>Pigeons.ScaledPrecisionNormalPath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ScaledPrecisionNormalPath(dim)
</code></pre><p>Toy Multivariate Normal (MVN) path of distributions for testing:  see section I.4.1 in Syed et al 2021. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/paths/ScaledPrecisionNormalPath.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Schedule" href="#Pigeons.Schedule"><code>Pigeons.Schedule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A partition of [0, 1] encoded by monotonically increasing grid points  starting at zero and ending at one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/schedules/Schedule.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Shared" href="#Pigeons.Shared"><code>Pigeons.Shared</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Information shared by all processes involved in  a round of distributed parallel tempering.  This is updated between rounds but only read during  a round. </p><p>Fields:</p><ul><li><code>iterators</code>: See <a href="#Pigeons.Iterators"><code>Iterators</code></a>.</li></ul><ul><li><code>tempering</code>: See <a href="../interfaces/#Pigeons.tempering"><code>tempering</code></a>.</li></ul><ul><li><code>explorer</code>: See <a href="../interfaces/#Pigeons.explorer"><code>explorer</code></a>.</li></ul><p>Only one instance maintained per process. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/Shared.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Shared-Tuple{Any}" href="#Pigeons.Shared-Tuple{Any}"><code>Pigeons.Shared</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Shared(inputs)
</code></pre><p>Create a <a href="#Pigeons.Shared"><code>Shared</code></a> struct based on an <a href="#Pigeons.Inputs"><code>Inputs</code></a>. </p><p>Uses <a href="#Pigeons.create_tempering-Tuple{Inputs}"><code>create_tempering()</code></a> and <a href="#Pigeons.create_explorer-Tuple{Any, Any}"><code>create_explorer()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/Shared.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.SliceSampler" href="#Pigeons.SliceSampler"><code>Pigeons.SliceSampler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Slice sampler based on <a href="https://projecteuclid.org/journals/annals-of-statistics/volume-31/issue-3/Slice-sampling/10.1214/aos/1056562461.full">Neal, 2003</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/samplers/SliceSampler.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Submission" href="#Pigeons.Submission"><code>Pigeons.Submission</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Specifies where to submit a task.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/Submission.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.SwapStat" href="#Pigeons.SwapStat"><code>Pigeons.SwapStat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Default statistics exchanged by a pair of chains in the process of proposing a swap:</p><ul><li><p><code>log_ratio</code></p></li><li><p><code>uniform</code></p></li></ul><p>See <a href="#Pigeons.swap_stat-Tuple{Any, Pigeons.Replica, Int64}"><code>swap_stat()</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/pair_swapper.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.TestSwapper" href="#Pigeons.TestSwapper"><code>Pigeons.TestSwapper</code></a> — <span class="docstring-category">Type</span></header><section><div><p>For testing/benchmarking purposes, a simple  <a href="../interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a> where all swaps have equal  acceptance probability. </p><p>Could also be used to warm-start swap connections  during exploration phase by setting that  constant probability to zero.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/pair_swapper.jl#L93-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.ThisProcess" href="#Pigeons.ThisProcess"><code>Pigeons.ThisProcess</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Flag to ask to run a function within the  current process. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/Submission.jl#L6-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.ToyExplorer" href="#Pigeons.ToyExplorer"><code>Pigeons.ToyExplorer</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Toy <a href="../interfaces/#Pigeons.explorer"><code>explorer</code></a> for toy paths where each <a href="../interfaces/#Pigeons.log_potential"><code>log_potential</code></a> supports  i.i.d. sampling via <code>rand(rng, log_potential)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/explorers/ToyExplorer.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.TuringLogPotential-Tuple{DynamicPPL.Model}" href="#Pigeons.TuringLogPotential-Tuple{DynamicPPL.Model}"><code>Pigeons.TuringLogPotential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">TuringLogPotential(model)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/targets/TuringLogPotential.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.NRPT-Tuple{Any, Any, Array{Vector{T}, 1} where T&lt;:Real, Int64, Int64}" href="#Pigeons.NRPT-Tuple{Any, Any, Array{Vector{T}, 1} where T&lt;:Real, Int64, Int64}"><code>Pigeons.NRPT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NRPT(V_0, V_1, initial_state, ntotal, N)</code></pre><p>Non-reversible parallel tempering (NRPT).</p><p><strong>Arguments</strong></p><ul><li><code>potential</code>: Function with three arguments (x, η, params) that returns a &#39;double&#39;.  &#39;x&#39; is the point at which the log-density V<em>0(x; params=params) * η[1] + V</em>1(x) * η[2] is evaluated,  where V<em>0 is the negative log density of the reference and V</em>1 is the negative  log density of the target.</li><li><code>initial_state</code>: Matrix of initial states for all N+1 chains. Dimensions: (N+1) x (dim_x).</li><li><code>ntotal</code>: Total number of scans/iterations.</li><li><code>N</code>: The total number of chains is N+1.</li><li><code>optimreference</code>: Whether the reference distribution is to be optimized.</li><li><code>maxround</code>: Maximum number of rounds for tuning.</li><li><code>fulltrajectory</code>: Controls whether to keep track of all &#39;states&#39;, &#39;indices&#39;, &#39;energies&#39;, and &#39;lifts&#39;.</li><li><code>ϕ</code>: (Partially removed. Useful for constructing non-linear paths.)</li><li><code>resolution</code>: Resolution of the output for the estimates of the local communication barrier. </li><li><code>prior_sampler</code>: User may supply an efficient sampler that can obtain   samples from the <em>prior</em> / original reference distribution.</li><li><code>optimreference_start</code>: On which tuning round to start optimizing the reference distribution.</li><li><code>full_covariance</code>: Controls whether to use a mean-field approximation for the modified   reference (false) or a full covariance matrix (true)</li><li><code>winsorize</code>: Whether or not to use a winsorized/trimmed mean when estimating </li></ul><p>the parameters of the variational reference</p><ul><li><code>two_references</code>: Whether to run two PT chains in parallel with two different references:   prior and variational reference. Note that with this setting there are 2*(N+1) chains in total.</li><li><code>modref_means_start</code>: Starting values for modref_means</li><li><code>modref_stds_start</code>: Starting values for modref_stds</li><li><code>n_explore</code>: Number of exploration steps to take before considering a communication swap</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/NRPT.jl#L27-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.acceptanceprobability-Tuple{Any, Any, Any}" href="#Pigeons.acceptanceprobability-Tuple{Any, Any, Any}"><code>Pigeons.acceptanceprobability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acceptanceprobability(newenergy, newenergy1, newenergy2)</code></pre><p>Compute acceptance probabilities for communication moves.  <code>newenergy</code> inputs are lists of numbers. </p><p><strong>Arguments</strong></p><ul><li><code>newenergy</code>: -log([π<em>β</em>0(x^0), π<em>β</em>1(x^1), ..., π<em>β</em>N(x^N)]) : length N+1</li><li><code>newenergy1</code>: -log([π<em>β</em>0(x^1), π<em>β</em>1(x^2), ..., π<em>β</em>{N-1}(x^N)]) : length N</li><li><code>newenergy2</code>: -log([π<em>β</em>1(x^0), π<em>β</em>2(x^1), ..., π<em>β</em>N(x^{N-1})]) : length N</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/acceptance.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.adapt-Tuple{Any, Any}" href="#Pigeons.adapt-Tuple{Any, Any}"><code>Pigeons.adapt</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adapt(pt, reduced_recorders)
</code></pre><p>Call <a href="#Pigeons.adapt_tempering-Tuple{Any, Any}"><code>adapt_tempering()</code></a> followed by  <a href="#Pigeons.adapt_explorer-Tuple{Any, Any, Any}"><code>adapt_explorer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/pigeons.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.adapt_explorer-Tuple{Any, Any, Any}" href="#Pigeons.adapt_explorer-Tuple{Any, Any, Any}"><code>Pigeons.adapt_explorer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adapt_explorer(explorer, reduced_recorders, shared)
</code></pre><p>Called between successive rounds (<a href="#Pigeons.run_one_round!-Tuple{Any}"><code>run_one_round!</code></a>). </p><p>Given an <a href="../interfaces/#Pigeons.explorer"><code>explorer</code></a>, reduced <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a>  and <a href="#Pigeons.Shared"><code>Shared</code></a> return an updated <a href="../interfaces/#Pigeons.explorer"><code>explorer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/explorers/explorer.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.adapt_tempering-Tuple{Any, Any}" href="#Pigeons.adapt_tempering-Tuple{Any, Any}"><code>Pigeons.adapt_tempering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adapt_tempering(tempering, reduced_recorders)
</code></pre><p>Called between successive rounds (<a href="#Pigeons.run_one_round!-Tuple{Any}"><code>run_one_round!</code></a>). </p><p>Given a <a href="../interfaces/#Pigeons.tempering"><code>tempering</code></a> and reduced <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a>  return an updated <a href="../interfaces/#Pigeons.tempering"><code>tempering</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/tempering/tempering.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.adapted_schedule-Tuple{Int64, Any}" href="#Pigeons.adapted_schedule-Tuple{Int64, Any}"><code>Pigeons.adapted_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">adapted_schedule(n_chains, cumulativebarrier)
</code></pre><p>Create a <a href="#Pigeons.Schedule"><code>Schedule</code></a> with <code>n_chains</code> grid points computed using Algorithm 2 in  Syed et al, 2021. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/schedules/Schedule.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.all_reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Pigeons.Entangler}} where T" href="#Pigeons.all_reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Pigeons.Entangler}} where T"><code>Pigeons.all_reduce_deterministically</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">all_reduce_deterministically(operation, source_data, e)
</code></pre><p>Same as <a href="#Pigeons.reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Pigeons.Entangler}} where T"><code>reduce_deterministically()</code></a> except that the result at the root of the  tree is then broadcast to all machines so that the output of <code>all_reduce_deterministically()</code>  is the root of the reduction tree for all MPI processes involved. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/Entangler.jl#L272">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.analytic_cumulativebarrier-Tuple{Pigeons.ScaledPrecisionNormalPath}" href="#Pigeons.analytic_cumulativebarrier-Tuple{Pigeons.ScaledPrecisionNormalPath}"><code>Pigeons.analytic_cumulativebarrier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">analytic_cumulativebarrier(path)
</code></pre><p>Known cumulative barrier used for testing,  from <a href="https://aip.scitation.org/doi/10.1063/1.1644093">Predescu et al., 2003</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/paths/ScaledPrecisionNormalPath.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.check_against_serial-Tuple{Any}" href="#Pigeons.check_against_serial-Tuple{Any}"><code>Pigeons.check_against_serial</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Run a separate, fully serial version of the PT algorithm,  and compare the checkpoint files to ensure the two  produce exactly the same output.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/checks/checks.jl#L28-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.checksum" href="#Pigeons.checksum"><code>Pigeons.checksum</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">checksum(filename)
checksum(filename, blocksize)
</code></pre><p>Given a filename path, compute a <code>crc32c()</code> checksum  in constant memory. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/misc.jl#L129-L135">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.communicate!-Tuple{Any}" href="#Pigeons.communicate!-Tuple{Any}"><code>Pigeons.communicate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">communicate!(pt)
</code></pre><p>Use <a href="#Pigeons.create_pair_swapper-Tuple{Any, Any}"><code>create_pair_swapper()</code></a> and  <a href="#Pigeons.create_swap_graph-Tuple{Any, Any}"><code>create_swap_graph</code></a> to construct the  inputs needed for <a href="#Pigeons.swap!-Tuple{Any, Any, Any}"><code>swap!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/pigeons.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.communicationbarrier-Tuple{AbstractVector, AbstractVector}" href="#Pigeons.communicationbarrier-Tuple{AbstractVector, AbstractVector}"><code>Pigeons.communicationbarrier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">communicationbarrier(rejection, schedule)
</code></pre><p>Compute the local communication barrier and cumulative barrier functions from the  <code>rejection</code> rates and the current annealing <code>schedule</code>. The estimation of the barriers  is based on Fritsch-Carlson monotonic interpolation.</p><p>Returns a <code>NamedTuple</code> with fields:</p><ul><li><code>localbarrier</code></li><li><code>cumulativebarrier</code></li><li><code>globalbarrier</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/adaptation.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.communicator-Tuple{Any}" href="#Pigeons.communicator-Tuple{Any}"><code>Pigeons.communicator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">communicator(replicas)
</code></pre><p>Return the <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a>&#39;s <code>MPI.Comm</code> or <code>nothing</code> if no MPI needed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/replicas.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.computeetas-Tuple{Any, Any}" href="#Pigeons.computeetas-Tuple{Any, Any}"><code>Pigeons.computeetas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeetas(ϕ, β)</code></pre><p>Compute the <code>etas</code> matrix given <code>ϕ</code>, which is an Array(K - 1, 2) containing  knot parameters, and <code>β</code>, a vector of <code>N</code>+1 schedules. For linear paths,  the function returns an (N+1)x2 matrix with entries 1-β in the first column  and β in the second column. (This function is useful for those wishing to consider non-linear paths. However, full support is provided only for linear paths at  the moment.) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/misc.jl#L61-L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_entangled_replicas-Tuple{Inputs, Pigeons.Shared, Any}" href="#Pigeons.create_entangled_replicas-Tuple{Inputs, Pigeons.Shared, Any}"><code>Pigeons.create_entangled_replicas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_entangled_replicas(inputs, shared, source)
</code></pre><p>Create distributed replicas. </p><p>See <a href="#Pigeons.create_replicas-Tuple{Inputs, Pigeons.Shared, Any}"><code>create_replicas</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/EntangledReplicas.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_explorer-Tuple{Any, Any}" href="#Pigeons.create_explorer-Tuple{Any, Any}"><code>Pigeons.create_explorer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_explorer(target, inputs)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/samplers/SliceSampler.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_explorer-Tuple{Any, Inputs}" href="#Pigeons.create_explorer-Tuple{Any, Inputs}"><code>Pigeons.create_explorer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_explorer(target, inputs)
</code></pre><p>Create an <a href="../interfaces/#Pigeons.explorer"><code>explorer</code></a> for the given <a href="../interfaces/#Pigeons.target"><code>target</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/targets/target.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_explorer-Tuple{Any}" href="#Pigeons.create_explorer-Tuple{Any}"><code>Pigeons.create_explorer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_explorer(inputs)
</code></pre><p>Given an <a href="#Pigeons.Inputs"><code>Inputs</code></a> object, dispatch on  <code>create_explorer(inputs.target, inputs)</code> to construct the  explorer associated with the input target distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/explorers/explorer.jl#L48-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_pair_swapper-Tuple{Any, Any}" href="#Pigeons.create_pair_swapper-Tuple{Any, Any}"><code>Pigeons.create_pair_swapper</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_pair_swapper(tempering, target)
</code></pre><p>Given a <a href="../interfaces/#Pigeons.tempering"><code>tempering</code></a> and a <a href="#Pigeons.Shared"><code>Shared</code></a> struct,  create a <a href="../interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a>. </p><p>If ommitted, by default will return the standard Metropolis-Hastings  accept-reject. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/tempering/tempering.jl#L30-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_path-Tuple{Any, Inputs}" href="#Pigeons.create_path-Tuple{Any, Inputs}"><code>Pigeons.create_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_path(target, inputs)
</code></pre><p>Create a <a href="../interfaces/#Pigeons.path"><code>path</code></a>, by default linking the given <a href="../interfaces/#Pigeons.target"><code>target</code></a> to  the refence provided by <a href="#Pigeons.create_reference_log_potential-Tuple{Any, Inputs}"><code>create_reference_log_potential()</code></a>.</p><p>For this default to work, the target should conform both  <a href="../interfaces/#Pigeons.target"><code>target</code></a> and <a href="../interfaces/#Pigeons.log_potential"><code>log_potential</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/targets/target.jl#L41-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_path-Tuple{Pigeons.ScaledPrecisionNormalPath, Inputs}" href="#Pigeons.create_path-Tuple{Pigeons.ScaledPrecisionNormalPath, Inputs}"><code>Pigeons.create_path</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_path(target, inputs)
</code></pre><p>In this case, the target is already a <a href="../interfaces/#Pigeons.path"><code>path</code></a>, so return it. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/paths/ScaledPrecisionNormalPath.jl#L39-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_recorders-Tuple{Any}" href="#Pigeons.create_recorders-Tuple{Any}"><code>Pigeons.create_recorders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_recorders(recorder_builders)
</code></pre><p>Create a <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a> from an iterable with element  type <a href="../interfaces/#Pigeons.recorder_builder"><code>recorder_builder</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/recorders/recorders.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_recorders-Tuple{Inputs, Pigeons.Shared}" href="#Pigeons.create_recorders-Tuple{Inputs, Pigeons.Shared}"><code>Pigeons.create_recorders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_recorders(inputs, shared)
</code></pre><p>Create a <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a> from an <a href="#Pigeons.Inputs"><code>Inputs</code></a> and <a href="#Pigeons.Shared"><code>Shared</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/recorders/recorders.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_reference_log_potential-Tuple{Any, Inputs}" href="#Pigeons.create_reference_log_potential-Tuple{Any, Inputs}"><code>Pigeons.create_reference_log_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_reference_log_potential(target, inputs)
</code></pre><p>Create a default reference distribution, by returning a  <a href="../interfaces/#Pigeons.log_potential"><code>log_potential</code></a>. The returned object will also get  passed to <a href="#Pigeons.sample_iid!-Tuple{Any, Any}"><code>sample_iid!()</code></a> at the &quot;hot chains&quot; of  the Parallel Tempering algorithm. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/targets/target.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_replicas-Tuple{Inputs, Pigeons.Shared, Any}" href="#Pigeons.create_replicas-Tuple{Inputs, Pigeons.Shared, Any}"><code>Pigeons.create_replicas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_replicas(inputs, shared, source)
</code></pre><p>Create <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a>, detecting automatically if MPI is needed. </p><p>Argument <code>source</code> is either a <a href="../interfaces/#Pigeons.state_initializer"><code>state_initializer</code></a> to create  fresh <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a>, or <a href="#Pigeons.FromCheckpoint"><code>FromCheckpoint</code></a> to load from  a saved checkpoint.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/replicas.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_state_initializer-Tuple{Any, Inputs}" href="#Pigeons.create_state_initializer-Tuple{Any, Inputs}"><code>Pigeons.create_state_initializer</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_state_initializer(target, inputs)
</code></pre><p>Return a <a href="../interfaces/#Pigeons.state_initializer"><code>state_initializer</code></a> used to populate  the states at the beginning of the first round of  Parallel Tempering. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/targets/target.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_swap_graph-Tuple{Any, Any}" href="#Pigeons.create_swap_graph-Tuple{Any, Any}"><code>Pigeons.create_swap_graph</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_swap_graph(swap_graphs, shared)
</code></pre><p>Given a <a href="../interfaces/#Pigeons.swap_graphs"><code>swap_graphs</code></a> and <a href="#Pigeons.Shared"><code>Shared</code></a>, return  the <a href="../interfaces/#Pigeons.swap_graph"><code>swap_graph</code></a> for the current iteration. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/swap_graphs.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_tempering-Tuple{Inputs}" href="#Pigeons.create_tempering-Tuple{Inputs}"><code>Pigeons.create_tempering</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_tempering(inputs)
</code></pre><p>Build the <a href="../interfaces/#Pigeons.tempering"><code>tempering</code></a> need for <a href="#Pigeons.communicate!-Tuple{Any}"><code>communicate!()</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/tempering/tempering.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_vector_replicas-Tuple{Inputs, Pigeons.Shared, Any}" href="#Pigeons.create_vector_replicas-Tuple{Inputs, Pigeons.Shared, Any}"><code>Pigeons.create_vector_replicas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">create_vector_replicas(inputs, shared, source)
</code></pre><p>Create <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a> when distributed computing is not needed.  See also <a href="../interfaces/#Pigeons.state_initializer"><code>state_initializer</code></a>.</p><p>See <a href="#Pigeons.create_replicas-Tuple{Inputs, Pigeons.Shared, Any}"><code>create_replicas</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/replicas.jl#L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.deo-Tuple{Any, Any, Any, Any, Any, Any, Int64, Int64, Int64, Any, Any, Any, Any, Bool, Any, Int64}" href="#Pigeons.deo-Tuple{Any, Any, Any, Any, Any, Any, Int64, Int64, Int64, Any, Any, Any, Any, Bool, Any, Int64}"><code>Pigeons.deo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deo(potential, initial_state, initial_index, initial_lift, schedule, ϕ, 
    nscan, N, resolution, optimreference_round, modref_means, modref_stds, modref_covs, 
    full_covariance, prior_sampler, n_explore)</code></pre><p>Deterministic even-odd parallel tempering (DEO/NRPT).</p><p><strong>Arguments</strong></p><ul><li><code>potential</code>: Function as in NRPT, but with only two arguments: x and η</li><li><code>initial_state</code>: Starting state, as in NRPT. Input is of size: N+1 [ dim_x ]</li><li><code>initial_index</code>: Starting indices</li><li><code>initial_lift</code>: Starting lift</li><li><code>schedule</code>: Annealing schedule</li><li><code>ϕ</code>: As in NRPT</li><li><code>nscan</code>: Number of scans to use</li><li><code>N</code>: As in NRPT</li><li><code>resolution</code>: As in NRPT</li><li><code>optimreference_round</code>: As in NRPT</li><li><code>modref_means</code></li><li><code>modref_stds</code></li><li><code>prior_sample</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/deo.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.deo-Tuple{Any}" href="#Pigeons.deo-Tuple{Any}"><code>Pigeons.deo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deo(n_chains)
</code></pre><p>Implements the Deterministic Even Odd (DEO) scheme proposed in <a href="https://www.sciencedirect.com/science/article/pii/S0009261401000550">Okabe, 2001</a> and analyzed in <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al., 2021</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/DEO.jl#L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.deoscan-NTuple{15, Any}" href="#Pigeons.deoscan-NTuple{15, Any}"><code>Pigeons.deoscan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deoscan(potential, state, index, lift, etas, n, N, kernels, 
    optimreference_round, modref_means, modref_stds, modref_covs, full_covariance, 
    prior_sampler, n_explore)</code></pre><p>Perform one DEO scan (local exploration + communication). Arguments are  similar to those for <code>deo()</code>. Note that <code>state</code> is the state from the <strong>one</strong> previous  scan, which is of size N+1[dim_x].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/deo.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.deserialize_immutables-Tuple{AbstractString}" href="#Pigeons.deserialize_immutables-Tuple{AbstractString}"><code>Pigeons.deserialize_immutables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deserialize_immutables(filename)
</code></pre><p>See <a href="#Pigeons.Immutable-Tuple{Any}"><code>Immutable()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/Immutable.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.discretize-Tuple{Any, Pigeons.Schedule}" href="#Pigeons.discretize-Tuple{Any, Pigeons.Schedule}"><code>Pigeons.discretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discretize(path, betas)
</code></pre><p>Create <a href="../interfaces/#Pigeons.log_potentials"><code>log_potentials</code></a> from a <a href="../interfaces/#Pigeons.path"><code>path</code></a> by interpolating the  path at each grid point specified in the <a href="#Pigeons.Schedule"><code>Schedule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/schedules/discretize.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.entangler-Tuple{Any}" href="#Pigeons.entangler-Tuple{Any}"><code>Pigeons.entangler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">entangler(replicas)
</code></pre><p>Return the <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a>&#39;s <a href="#Pigeons.Entangler"><code>Entangler</code></a> (possibly a no-communication Entangler if a single process is involved)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/replicas.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.equally_spaced_schedule-Tuple{Int64}" href="#Pigeons.equally_spaced_schedule-Tuple{Int64}"><code>Pigeons.equally_spaced_schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">equally_spaced_schedule(n_chains)
</code></pre><p>Create a <a href="#Pigeons.Schedule"><code>Schedule</code></a> with <code>n_chains</code> equally spaced grid points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/schedules/Schedule.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.explore!-Tuple{Any, Any, Val{false}}" href="#Pigeons.explore!-Tuple{Any, Any, Val{false}}"><code>Pigeons.explore!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">explore!(pt, explorer, multithreaded)
</code></pre><p>The @thread macro brings a large overhead even  when Threads.nthreads == 1, so treating each case  separately</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/pigeons.jl#L87">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.explore!-Tuple{Any, Any, Val{true}}" href="#Pigeons.explore!-Tuple{Any, Any, Val{true}}"><code>Pigeons.explore!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">explore!(pt, explorer, multithreaded_flag)
</code></pre><p>Call <a href="#Pigeons.sample_iid!-Tuple{Any, Any}"><code>sample_iid!</code></a> or <a href="#Pigeons.step!-Tuple{Any, Any, Any}"><code>step!()</code></a> on  each chain (depending if it is a reference or not  respectively). </p><p>Uses <code>@threads</code> to parallelize across threads.  This is safe by the contract described in  <a href="#Pigeons.sample_iid!-Tuple{Any, Any}"><code>sample_iid!</code></a> and <a href="#Pigeons.step!-Tuple{Any, Any, Any}"><code>step!()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/pigeons.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.explorer_recorder_builders-Tuple{Any}" href="#Pigeons.explorer_recorder_builders-Tuple{Any}"><code>Pigeons.explorer_recorder_builders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">explorer_recorder_builders(explorer)
</code></pre><p>What information is needed to perform <a href="#Pigeons.adapt_explorer-Tuple{Any, Any, Any}"><code>adapt_explorer</code></a>? Answer this by specifying an iterator containing <a href="../interfaces/#Pigeons.recorder_builder"><code>recorder_builder</code></a>&#39;s.  Return <code>[]</code> if none are needed. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/explorers/explorer.jl#L30-L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.find_global_index-Tuple{Pigeons.LoadBalance, Int64}" href="#Pigeons.find_global_index-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_global_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_global_index(lb, local_idx)
</code></pre><p>Find the global index corresponding to the given <code>local_index</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/LoadBalance.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.find_local_index-Tuple{Pigeons.LoadBalance, Int64}" href="#Pigeons.find_local_index-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_local_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_local_index(lb, global_idx)
</code></pre><p>Find the local index corresponding to the given <code>global_index</code>.  Assumes the given <code>global_index</code> is one of this process&#39;. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/LoadBalance.jl#L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.find_log_potential-Tuple{Any, Any}" href="#Pigeons.find_log_potential-Tuple{Any, Any}"><code>Pigeons.find_log_potential</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_log_potential(replica, shared)
</code></pre><p>Find the <a href="../interfaces/#Pigeons.log_potential"><code>log_potential</code></a> for the chain  the replica is at, based on the <a href="#Pigeons.Shared"><code>Shared</code></a> object.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/explorers/explorer.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.find_process-Tuple{Pigeons.LoadBalance, Int64}" href="#Pigeons.find_process-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_process</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_process(lb, global_idx)
</code></pre><p>Find the process id (1-indexed) responsible for the given <code>global_idx</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/LoadBalance.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.flush_immutables!-Tuple{}" href="#Pigeons.flush_immutables!-Tuple{}"><code>Pigeons.flush_immutables!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">flush_immutables!()
</code></pre><p>See <a href="#Pigeons.Immutable-Tuple{Any}"><code>Immutable()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/Immutable.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.index_process-Tuple{}" href="#Pigeons.index_process-Tuple{}"><code>Pigeons.index_process</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Full index process stored in memory. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/recorders/recorder.jl#L28-L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.index_process_plot-Tuple{Any}" href="#Pigeons.index_process_plot-Tuple{Any}"><code>Pigeons.index_process_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_process_plot(recorders)
</code></pre><p>Given a <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a>, create an index process plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/swap.jl#L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.informal_doc-Tuple{Any, Module}" href="#Pigeons.informal_doc-Tuple{Any, Module}"><code>Pigeons.informal_doc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">informal_doc(doc_dir, mod)
</code></pre><p>Generate informal interface documentation, e.g.: </p><pre><code class="nohighlight hljs">makedocs(;
    ...
    pages=[
        &quot;Home&quot; =&gt; &quot;index.md&quot;, 
        &quot;Interfaces&quot; =&gt; informal_doc(@__DIR__, MyModuleName),
        ...
    ]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/@informal.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.initialization-Tuple{Any, SplittableRandoms.SplittableRandom, Int64}" href="#Pigeons.initialization-Tuple{Any, SplittableRandoms.SplittableRandom, Int64}"><code>Pigeons.initialization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialization(state_initializer, rng, replica_index)
</code></pre><p>Determine <a href="../interfaces/#Pigeons.state_initializer"><code>state_initializer</code></a>&#39;s initialization for the given <code>replica_index</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/replicas.jl#L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.interpolate-Tuple{Any, Any}" href="#Pigeons.interpolate-Tuple{Any, Any}"><code>Pigeons.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(path, beta)
</code></pre><p>Returns the <a href="../interfaces/#Pigeons.log_potential"><code>log_potential</code></a> at point <code>beta</code> in the <a href="../interfaces/#Pigeons.path"><code>path</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/paths/path.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.is_finished-Tuple{AbstractString, Any}" href="#Pigeons.is_finished-Tuple{AbstractString, Any}"><code>Pigeons.is_finished</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">is_finished(checkpoint_folder, inputs)
</code></pre><p>Is the provided path to a checkpoint folder complete?  I.e. check in the .signal subfolder that all MPI processes have  signaled that they are done.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/checkpoint.jl#L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.latest_checkpoint_folder-Tuple{Any}" href="#Pigeons.latest_checkpoint_folder-Tuple{Any}"><code>Pigeons.latest_checkpoint_folder</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">latest_checkpoint_folder(exec_folder)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/checkpoint.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.load-Tuple{Any}" href="#Pigeons.load-Tuple{Any}"><code>Pigeons.load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load(replicas)
</code></pre><p>Return the <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a>&#39;s <a href="#Pigeons.LoadBalance"><code>LoadBalance</code></a> (possibly <a href="#Pigeons.single_process_load-Tuple{Any}"><code>single_process_load</code></a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/replicas.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.load-Union{Tuple{Result{T}}, Tuple{T}} where T" href="#Pigeons.load-Union{Tuple{Result{T}}, Tuple{T}} where T"><code>Pigeons.load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load(replicas)
load(result)
</code></pre><p>Load the result in memory.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/Result.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.local_exploration-NTuple{9, Any}" href="#Pigeons.local_exploration-NTuple{9, Any}"><code>Pigeons.local_exploration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">local_exploration(states, kernels, optimreference_round, modref_means, modref_stds, 
    modref_covs, full_covariance, prior_sampler, n_explore)
    chainacceptance = Vector{Int64}(undef, length(states))</code></pre><p>Perform one local exploration move. <code>state</code> is the state from the <strong>one</strong>  previous scan, which is of size N+1[dim_x].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/exploration.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.locals-Tuple{Any}" href="#Pigeons.locals-Tuple{Any}"><code>Pigeons.locals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">locals(replicas)
</code></pre><p>Return the replica&#39;s that are stored in this machine</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/replicas.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.log_unnormalized_ratio-Tuple{AbstractVector, Int64, Int64, Any}" href="#Pigeons.log_unnormalized_ratio-Tuple{AbstractVector, Int64, Int64, Any}"><code>Pigeons.log_unnormalized_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_unnormalized_ratio(
    log_potentials::AbstractVector,
    numerator::Int64,
    denominator::Int64,
    state
) -&gt; Any
</code></pre><p>Assumes the input <code>log_potentials</code> is a vector where each element is a <a href="../interfaces/#Pigeons.log_potential"><code>log_potential</code></a>.</p><p>This default implementation is sufficient in most cases, but in less standard scenarios, e.g. where the state space is infinite dimensional, this can be overridden. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/log_potentials/log_potentials.jl#L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.log_unnormalized_ratio-Tuple{Any, Int64, Int64, Any}" href="#Pigeons.log_unnormalized_ratio-Tuple{Any, Int64, Int64, Any}"><code>Pigeons.log_unnormalized_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_unnormalized_ratio(
    log_potentials,
    numerator,
    denominator,
    state
)
</code></pre><p>The argument <code>numerator</code> selects one distribution <span>$\pi_i$</span> from the collection <a href="../interfaces/#Pigeons.log_potentials"><code>log_potentials</code></a>,  and similarly <code>denominator</code> selects <span>$\pi_j$</span>. Let <span>$x$</span> denote the input <code>state</code>. The ratio:</p><p class="math-container">\[f(x) = \frac{\text{d}\pi_i}{\text{d}\pi_j}(x)\]</p><p>may only be known up to a normalization constant which can depend on <span>$i$</span> and <span>$j$</span> but  not <span>$x$</span>, <span>$g(x) = C_{i,j} f(x)$</span>.</p><p>This function should return <span>$\log g$</span> evaluated at <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/log_potentials/log_potentials.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.lognormalizingconstant-Tuple{Any, Any}" href="#Pigeons.lognormalizingconstant-Tuple{Any, Any}"><code>Pigeons.lognormalizingconstant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lognormalizingconstant(energies, schedule)</code></pre><p>Compute an estimate of the log normalizing constant given a vector of  <code>energies</code> and the corresponding annealing <code>schedule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/misc.jl#L47-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.mpi_active-Tuple{}" href="#Pigeons.mpi_active-Tuple{}"><code>Pigeons.mpi_active</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mpi_active()
</code></pre><p>Detect if more than one MPI processes can be found. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/Entangler.jl#L80">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.my_global_indices-Tuple{Pigeons.LoadBalance}" href="#Pigeons.my_global_indices-Tuple{Pigeons.LoadBalance}"><code>Pigeons.my_global_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">my_global_indices(lb)
</code></pre><p>The slice of <code>lb.global_indices</code> this process is reponsible for.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/LoadBalance.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.my_load-Tuple{Pigeons.LoadBalance}" href="#Pigeons.my_load-Tuple{Pigeons.LoadBalance}"><code>Pigeons.my_load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">my_load(lb::Pigeons.LoadBalance) -&gt; Int64
</code></pre><p>Return the number of indices (task) this process is responsible for. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/LoadBalance.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.n_chains-Tuple{Any}" href="#Pigeons.n_chains-Tuple{Any}"><code>Pigeons.n_chains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_chains(log_potentials)
</code></pre><p>The number of chains in the <a href="../interfaces/#Pigeons.log_potentials"><code>log_potentials</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/log_potentials/log_potentials.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.next_exec_folder-Tuple{}" href="#Pigeons.next_exec_folder-Tuple{}"><code>Pigeons.next_exec_folder</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return a unique subfolder of  <code>results/all/</code>, making sure the  unique folder and its parents are created.  It will also create a soft symlink to it  called <code>results/latest</code>`</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/exec_folder.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.one_per_host-Tuple{Any}" href="#Pigeons.one_per_host-Tuple{Any}"><code>Pigeons.one_per_host</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For benchmarking purpose: subset the communicator so that at most one MPI process runs      in each machine.</p><p>Division is done so that original rank 0 is always included.</p><p>Return the new communicator or nothing if this machine is not in the subset. </p><p>See also &#39;-s&#39; option in mpi-run</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/one_per_host.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.only_one_process-Tuple{Any, Any}" href="#Pigeons.only_one_process-Tuple{Any, Any}"><code>Pigeons.only_one_process</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">only_one_process(task, pt)
</code></pre><p>A task that should be ran on only one of the processes.  Using the <code>do .. end</code> syntax, this can be used as:</p><pre><code class="nohighlight hljs">only_one_process(pt) do 
    ...
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/PT.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.partner_chain-Tuple{Any, Int64}" href="#Pigeons.partner_chain-Tuple{Any, Int64}"><code>Pigeons.partner_chain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partner_chain(swap_graph, chain)
</code></pre><p>For a given <a href="../interfaces/#Pigeons.swap_graph"><code>swap_graph</code></a> and input <code>chain</code> index, what chain will it interact with at the current iteration? Convention: if a chain is not interacting, return its index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/swap_graph.jl#L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.permuted_get-Union{Tuple{T}, Tuple{Pigeons.PermutedDistributedArray{T}, AbstractVector{Int64}}} where T" href="#Pigeons.permuted_get-Union{Tuple{T}, Tuple{Pigeons.PermutedDistributedArray{T}, AbstractVector{Int64}}} where T"><code>Pigeons.permuted_get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permuted_get(p, indices)
</code></pre><p>Retreive the values for the given <code>indices</code>, using MPI communication when needed. </p><p>We make the following assumptions:</p><ul><li><code>length(indices) == my_load(p.entangler.load)</code></li><li>the <code>indices</code> across all participating processes form a permutation of the global indices. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/PermutedDistributedArray.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.permuted_set!-Union{Tuple{T}, Tuple{Pigeons.PermutedDistributedArray{T}, AbstractVector{T}, AbstractVector{T}}} where T" href="#Pigeons.permuted_set!-Union{Tuple{T}, Tuple{Pigeons.PermutedDistributedArray{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>Pigeons.permuted_set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permuted_set!(p, indices, new_values)
</code></pre><p>Set the values for the given <code>indices</code> to the given <code>new_values</code>, using MPI communication when needed. </p><p>We make the same assumptions as in <a href="#Pigeons.permuted_get-Union{Tuple{T}, Tuple{Pigeons.PermutedDistributedArray{T}, AbstractVector{Int64}}} where T"><code>permuted_get()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/PermutedDistributedArray.jl#L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.pigeons-Tuple{Any, ChildProcess}" href="#Pigeons.pigeons-Tuple{Any, ChildProcess}"><code>Pigeons.pigeons</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pigeons(pt_arguments, new_process)
</code></pre><p>Run Parallel Tempering in a new process.  See <a href="#Pigeons.ChildProcess"><code>ChildProcess</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/ChildProcess.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.pigeons-Tuple{Any, MPI}" href="#Pigeons.pigeons-Tuple{Any, MPI}"><code>Pigeons.pigeons</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pigeons(pt_arguments, mpi_submission)
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/MPI.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.pigeons-Tuple{Any}" href="#Pigeons.pigeons-Tuple{Any}"><code>Pigeons.pigeons</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pigeons(pt_arguments; on)
</code></pre><p><code>pt_arguments</code> can be either an <a href="#Pigeons.Inputs"><code>Inputs</code></a>, to start  a new Parallel Tempering algorithm, or a string pointing to  an execution to resume. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/api.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.pigeons-Tuple{PT}" href="#Pigeons.pigeons-Tuple{PT}"><code>Pigeons.pigeons</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pigeons(pt)
</code></pre><p>Run (a generalization of) Parallel Tempering. </p><p>This will call several rounds of <a href="#Pigeons.run_one_round!-Tuple{Any}"><code>run_one_round!()</code></a>,  performing adaptation between each round via <a href="#Pigeons.adapt-Tuple{Any, Any}"><code>adapt()</code></a>.</p><p>This will also call <a href="#Pigeons.report-Tuple{Any, Any}"><code>report()</code></a>, <a href="#Pigeons.write_checkpoint-Tuple{Any, Any}"><code>write_checkpoint()</code></a>,  and <a href="#Pigeons.run_checks-Tuple{Any}"><code>run_checks()</code></a> between rounds. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/pigeons.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.pigeons-Tuple{}" href="#Pigeons.pigeons-Tuple{}"><code>Pigeons.pigeons</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pigeons(; on, args...)
</code></pre><p>Passes the <code>args...</code> to <a href="#Pigeons.Inputs"><code>Inputs</code></a> and start  a new Parallel Tempering algorithm with that inputs. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/api.jl#L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.providers-Tuple{Module, Symbol}" href="#Pigeons.providers-Tuple{Module, Symbol}"><code>Pigeons.providers</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">providers(mod, name)
</code></pre><p>Provides a <code>Set{Expr}</code> containing all the providers of the  given name in the given module. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/@informal.jl#L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record!-Tuple{Any, Any}" href="#Pigeons.record!-Tuple{Any, Any}"><code>Pigeons.record!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record!(recorder, value)
</code></pre><p>Add <code>value</code> to the statistics accumulated by <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/recorders/recorder.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record!-Tuple{OnlineStatsBase.OnlineStat, Any}" href="#Pigeons.record!-Tuple{OnlineStatsBase.OnlineStat, Any}"><code>Pigeons.record!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record!(recorder, value)
</code></pre><p>Forwards to OnlineStats&#39; <code>fit!</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/recorders/recorder.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record!-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K, Vector{V}}, Tuple{K, V}}} where {K, V}" href="#Pigeons.record!-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K, Vector{V}}, Tuple{K, V}}} where {K, V}"><code>Pigeons.record!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record!(recorder, value)
</code></pre><p>Given a <code>value</code>, a pair <code>(a, b)</code>, and a <code>Dict{K, Vector{V}}</code> backed  <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a>,  append <code>b</code> to the vector corresponding to <code>a</code>, inserting an empty  vector into the dictionary first if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/recorders/recorder.jl#L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record_if_requested!-Tuple{Any, Symbol, Any}" href="#Pigeons.record_if_requested!-Tuple{Any, Symbol, Any}"><code>Pigeons.record_if_requested!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record_if_requested!(recorders, recorder_key, value)
</code></pre><p>If the <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a> contains the given <code>recorder_key</code>,  send the <code>value</code> to the <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a> corresponding to the  <code>recorder_key</code>. Otherwise, do nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/recorders/recorders.jl#L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record_swap_stats!-Tuple{Any, Any, Int64, Any, Int64, Any}" href="#Pigeons.record_swap_stats!-Tuple{Any, Any, Int64, Any, Int64, Any}"><code>Pigeons.record_swap_stats!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record_swap_stats!(
    pair_swapper,
    recorders,
    chain1,
    stat1,
    chain2,
    stat2
)
</code></pre><p>Given a <a href="../interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a>, a <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a>, the provided chain indices, and  the sufficient statistics computed by <a href="#Pigeons.swap_stat-Tuple{Any, Pigeons.Replica, Int64}"><code>swap_stat()</code></a>, record statistics. </p><p>To avoid accumulating twice the same statistic with (chain1, chain2) and  (chain2, chain2), <a href="#Pigeons.swap!-Tuple{Any, Any, Any}"><code>swap!()</code></a> only calls this for the pair with chain1 &lt; chain2.</p><p>By default, the following are accumulated:</p><ul><li>the swap acceptance probability.</li><li>TODO: stepping stone statistics.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/pair_swapper.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record_swap_stats!-Tuple{Pigeons.TestSwapper, Any, Int64, Any, Int64, Any}" href="#Pigeons.record_swap_stats!-Tuple{Pigeons.TestSwapper, Any, Int64, Any, Int64, Any}"><code>Pigeons.record_swap_stats!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record_swap_stats!(
    swapper,
    recorder,
    chain1,
    stat1,
    chain2,
    stat2
)
</code></pre><p>See <a href="#Pigeons.TestSwapper"><code>TestSwapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/pair_swapper.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Pigeons.Entangler}} where T" href="#Pigeons.reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Pigeons.Entangler}} where T"><code>Pigeons.reduce_deterministically</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_deterministically(operation, source_data, e)
</code></pre><p>Perform a binary <a href="https://en.wikipedia.org/wiki/MapReduce">reduction</a> of the  <code>source_data</code>, using MPI when needed. </p><p>Consider the binary tree with leaves given by the global indices specified in <code>e.load</code> and stored  in the different MPI processes&#39; input <code>source_data</code> vectors.  At each node of the tree, a reduction is performed using <code>operation</code>, i.e.  by calling <code>operation(left_child, right_child)</code>. When, and only when a branch of the tree crosses from one MPI process to another one,  MPI communication is used to transmit the intermediate reduction. </p><p>At the end, for process 1, <code>reduce_deterministically()</code> will return the root of the  binary tree, and for the other processes, <code>reduce_deterministically()</code> will return  <code>nothing</code>. </p><p>Note that even when the <code>operation</code> is only approximately associative (typical situation  for floating point reductions), the output of this function is invariant to the  number of MPI processes involved (hence the terminology &#39;deterministically&#39;).  This contrasts to direct use of MPI collective communications where the leaves are  MPI processes and hence will give slightly different outputs given different  numbers of MPI processes. In the context of randomized algorithms, these minor  differences are then amplified. </p><p>In contrast to <a href="#Pigeons.transmit!-Union{Tuple{T}, Tuple{Pigeons.Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T"><code>transmit!()</code></a>, we do not assume <code>isbitstype(T) == true</code> and use  serialization when messages are transmitted over MPI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/Entangler.jl#L183">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.reduce_recorders!-Tuple{Pigeons.EntangledReplicas}" href="#Pigeons.reduce_recorders!-Tuple{Pigeons.EntangledReplicas}"><code>Pigeons.reduce_recorders!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_recorders!(replicas)
</code></pre><p>Perform a reduction across all the replicas&#39; individual recorders,  using <a href="@ref"><code>merge()</code></a> on each individual <a href="../interfaces/#Pigeons.recorder"><code>recorder</code></a> held. Returns a <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a> with all the information merged. </p><p>Will reset the replicas&#39; recorders at the same time using <a href="@ref"><code>empty!()</code></a>.</p><p>Since this uses <a href="#Pigeons.all_reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Pigeons.Entangler}} where T"><code>all_reduce_deterministically</code></a>, the output is  identical, no matter how many MPI processes are used, even when  the reduction involves only approximately associative <a href="@ref"><code>merge()</code></a> operations (e.g. most floating point ones).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/recorders/recorders.jl#L70">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.reference_chains-Tuple{Any, Any}" href="#Pigeons.reference_chains-Tuple{Any, Any}"><code>Pigeons.reference_chains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reference_chains(swap_graphs, shared)
</code></pre><p>Given a <a href="../interfaces/#Pigeons.swap_graphs"><code>swap_graphs</code></a> and <a href="#Pigeons.Shared"><code>Shared</code></a>, return  a <code>Set{Int}</code> of chain(s) indices targetting the distribution of interest. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/swap_graphs.jl#L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.report-Tuple{Any, Any}" href="#Pigeons.report-Tuple{Any, Any}"><code>Pigeons.report</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">report(pt, reduced_recorders)
</code></pre><p>Report summary information on the progress of <a href="#Pigeons.pigeons-Tuple{}"><code>pigeons()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/pigeons.jl#L24">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.restarts-Tuple{Any}" href="#Pigeons.restarts-Tuple{Any}"><code>Pigeons.restarts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restarts(indices_matrix; cumulative) -&gt; Any
</code></pre><p>Compute the number of restarts for a given index process trajectory.  Otherwise, it is the same as <code>roundtrip()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/restarts.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.roundtrip-Tuple{Any}" href="#Pigeons.roundtrip-Tuple{Any}"><code>Pigeons.roundtrip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roundtrip(indices_matrix; cumulative) -&gt; Any
</code></pre><p>Compute the number of round trips for a given index process trajectory.  <code>indices_matrix</code> is a matrix containing information about the index process. <code>cumulative</code> indicates whether we should store the output as a vector containing  information about the number of total round trips up to sample <code>n</code>. If false, the output is a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/restarts.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.run_checks-Tuple{Any}" href="#Pigeons.run_checks-Tuple{Any}"><code>Pigeons.run_checks</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Perform checks to detect software defects.  Unable via field <code>checked_round</code> in <a href="#Pigeons.Inputs"><code>Inputs</code></a> Currently the following checks are implemented:</p><ul><li><a href="#Pigeons.check_against_serial-Tuple{Any}"><code>check_against_serial()</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/checks/checks.jl#L10-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.run_one_round!-Tuple{Any}" href="#Pigeons.run_one_round!-Tuple{Any}"><code>Pigeons.run_one_round!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">run_one_round!(pt)
</code></pre><p>From a <a href="#Pigeons.PT"><code>PT</code></a> object, run one round of  a generalized version of Algorithm 1 in  <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al., 2021</a>.</p><p>Alternates between <a href="#Pigeons.communicate!-Tuple{Any}"><code>communicate!()</code></a>,  which consists of any pairwise communicating  moves and [<code>explore!()</code>], which consists in  moves independ to each chain. </p><p>Concrete specification of how to communicate and  explore are specified by the field of type <a href="#Pigeons.Shared"><code>Shared</code></a>  contained in the provided <a href="#Pigeons.PT"><code>PT</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/pigeons.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.sample_iid!-Tuple{Any, Any}" href="#Pigeons.sample_iid!-Tuple{Any, Any}"><code>Pigeons.sample_iid!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sample_iid!(reference_log_potential, replica)
</code></pre><p>Perform i.i.d. sampling on the given <a href="#Pigeons.Replica"><code>Replica</code></a>  during its visit to the reference<em>log</em>potential created  by <a href="#Pigeons.create_reference_log_potential-Tuple{Any, Inputs}"><code>create_reference_log_potential()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/targets/target.jl#L32">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.serialize_immutables-Tuple{AbstractString}" href="#Pigeons.serialize_immutables-Tuple{AbstractString}"><code>Pigeons.serialize_immutables</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">serialize_immutables(filename)
</code></pre><p>See <a href="#Pigeons.Immutable-Tuple{Any}"><code>Immutable()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/Immutable.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.setkernels-Tuple{Any, Any}" href="#Pigeons.setkernels-Tuple{Any, Any}"><code>Pigeons.setkernels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setkernels(potential, etas)</code></pre><p>Set the local exploration kernels given the <code>potential</code> and the annealing  parameters, <code>etas</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/exploration.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.setup_mpi-Tuple{Pigeons.MPISettings}" href="#Pigeons.setup_mpi-Tuple{Pigeons.MPISettings}"><code>Pigeons.setup_mpi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setup_mpi(settings)
</code></pre><p>Run this function once before running MPI jobs.  The setting are permanently saved</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/MPISettings.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.setup_mpi-Tuple{}" href="#Pigeons.setup_mpi-Tuple{}"><code>Pigeons.setup_mpi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setup_mpi(; args...)
</code></pre><p>Arguments are passed in the constructor of <a href="#Pigeons.MPISettings"><code>MPISettings</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/submission/MPISettings.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.single_process_load-Tuple{Any}" href="#Pigeons.single_process_load-Tuple{Any}"><code>Pigeons.single_process_load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">single_process_load(n_global_indices)
</code></pre><p>A load balance with only one process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/LoadBalance.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.slice_accept-Tuple{Pigeons.SliceSampler, Any, Any, Any, Any, Any, Any, Any}" href="#Pigeons.slice_accept-Tuple{Pigeons.SliceSampler, Any, Any, Any, Any, Any, Any, Any}"><code>Pigeons.slice_accept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice_accept(
    h,
    state,
    new_position,
    z,
    L,
    R,
    pointer,
    log_potential
)
</code></pre><p>Test whether to accept the current slice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/samplers/SliceSampler.jl#L134">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.slice_double-Tuple{Pigeons.SliceSampler, Any, Any, Any, Any, Any}" href="#Pigeons.slice_double-Tuple{Pigeons.SliceSampler, Any, Any, Any, Any, Any}"><code>Pigeons.slice_double</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice_double(h, state, z, pointer, log_potential, rng)
</code></pre><p>Double the current slice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/samplers/SliceSampler.jl#L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.slice_sample!-Tuple{Pigeons.SliceSampler, AbstractVector, Any, Any}" href="#Pigeons.slice_sample!-Tuple{Pigeons.SliceSampler, AbstractVector, Any, Any}"><code>Pigeons.slice_sample!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice_sample!(h, state, log_potential, rng)
</code></pre><p>Slice sample one point.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/samplers/SliceSampler.jl#L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.slice_shrink-Tuple{Pigeons.SliceSampler, Any, Any, Any, Any, Any, Any, Any}" href="#Pigeons.slice_shrink-Tuple{Pigeons.SliceSampler, Any, Any, Any, Any, Any, Any, Any}"><code>Pigeons.slice_shrink</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice_shrink(h, state, z, L, R, pointer, log_potential, rng)
</code></pre><p>Shrink the current slice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/samplers/SliceSampler.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.sort_includes!-Tuple{Any}" href="#Pigeons.sort_includes!-Tuple{Any}"><code>Pigeons.sort_includes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sort_includes!(main)
</code></pre><p>Heuristic to automate the process  of sorting <code>include()</code>&#39;s.</p><p>Topological sorting of the source files under src  (excluding <code>main</code>) is attempted, if successful, print the  include string to copy and paste to the main file, otherwise,  print the detected loops. </p><p>Internally, this function will:</p><ol><li>Construct a graph where the vertices are the .jl files   under src, excluding the provided <code>main</code> file (i.e. where the module is   defined and the includes will sit in).</li><li>Each file starting with a capital letter is assumed to   contain a struct with the same name as the file after   removal of the .jl suffix. Similarly, files starting   with <code>@</code> are assumed to contain a macro with the similarly   obtained name.</li><li>Each source file is inspected to see if the above struct and   macro strings are detected. This defines edges in the graph.  (known limitation: this includes spurious edges when e.g.   the string occurs in a comment).</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/misc.jl#L145">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.split_slice-Tuple{UnitRange, Any}" href="#Pigeons.split_slice-Tuple{UnitRange, Any}"><code>Pigeons.split_slice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_slice(slice, rng)
</code></pre><p>From one splittable random object, one can conceptualize an infinite list of splittable random objects.  Return a slice from this infinite list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/misc.jl#L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.step!-Tuple{Any, Any, Any}" href="#Pigeons.step!-Tuple{Any, Any, Any}"><code>Pigeons.step!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">step!(explorer, replica, shared)
</code></pre><p>Perform a transition on the given <a href="#Pigeons.Replica"><code>Replica</code></a>  invariant with respect to the distribution of the  replica&#39;s chain. </p><p>The input <a href="../interfaces/#Pigeons.explorer"><code>explorer</code></a> and <a href="#Pigeons.Shared"><code>Shared</code></a> should only  be read, not written to. </p><p>See also <a href="#Pigeons.find_log_potential-Tuple{Any, Any}"><code>find_log_potential</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/explorers/explorer.jl#L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap!-Tuple{Any, Any, Any}" href="#Pigeons.swap!-Tuple{Any, Any, Any}"><code>Pigeons.swap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap!(pair_swapper, replicas, swap_graph)
</code></pre><p>For each pair of chains encoded in <a href="../interfaces/#Pigeons.swap_graph"><code>swap_graph</code></a>, use  <a href="../interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a> to decide if the pair will swap or not,  and write the changes in-place into <a href="../interfaces/#Pigeons.replicas"><code>replicas</code></a> (i.e. exchanging  the <code>Replica</code>&#39;s <code>chain</code> fields for those that swapped.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/replicas/replicas.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap!-Tuple{Any, Pigeons.EntangledReplicas, Any}" href="#Pigeons.swap!-Tuple{Any, Pigeons.EntangledReplicas, Any}"><code>Pigeons.swap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap!(pair_swapper, replicas, swap_graph)
</code></pre><p>Entangled MPI <code>swap!</code> implementation.</p><p>This implementation is designed to support distributed PT with the following guarantees</p><ul><li>The running time is independent of the size of the state space      (&#39;swapping annealing parameters rather than states&#39;)</li><li>The output is identical no matter how many MPI processes are used. In particular,      this means that we can check correctness by comparing to the serial, single-process version.</li><li>Scalability to 1000s of processes communicating over MPI (see details below).</li><li>The same function can be used when a single process is used and MPI is not available.</li><li>Flexibility to extend PT to e.g. networks of targets and general paths.</li></ul><p>Running time analysis:</p><p>Let <span>$N$</span> denote the number of chains, <span>$P$</span>, the number of processes, and <span>$K = \text{ceil}(N/P)$</span>,   the maximum number of chains held by one process.  Assuming the running time is dominated by communication latency and  a constant time for the latency of each   peer-to-peer communication, the theoretical running time is <span>$O(K)$</span>.  In practice, latency will grow as a function of <span>$P$</span>, but empirically, this growth appears to be slow enough that for say <span>$P = N =$</span> a few 1000s,  swapping will not be the computational bottleneck.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/swap.jl#L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap!-Union{Tuple{R}, Tuple{Any, Vector{R}, Any}} where R" href="#Pigeons.swap!-Union{Tuple{R}, Tuple{Any, Vector{R}, Any}} where R"><code>Pigeons.swap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap!(pair_swapper, replicas, swap_graph)
</code></pre><p>Single process, non-allocating <code>swap!</code> implementation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/swap.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap_acceptance_pr-Tuple{}" href="#Pigeons.swap_acceptance_pr-Tuple{}"><code>Pigeons.swap_acceptance_pr</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Average MH swap acceptance probabilities for each pairs  of interacting chains. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/recorders/recorder.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap_decision-Tuple{Any, Int64, Any, Int64, Any}" href="#Pigeons.swap_decision-Tuple{Any, Int64, Any, Int64, Any}"><code>Pigeons.swap_decision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap_decision(pair_swapper, chain1, stat1, chain2, stat2)
</code></pre><p>Given a <a href="../interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a>, a <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a>, the provided chain indices, and  the sufficient statistics computed by <a href="#Pigeons.swap_stat-Tuple{Any, Pigeons.Replica, Int64}"><code>swap_stat()</code></a>, make a swap decision.</p><p>By default, this is done as follows:</p><ol><li>compute the standard swap acceptance probability <code>min(1, exp(stat1.log_ratio + stat2.log_ratio))</code></li><li>make sure the two chains share the same uniform by picking the uniform from the chain with the smallest chain index </li><li>swap if the shared uniform is smaller than the swap acceptance probability.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/pair_swapper.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap_decision-Tuple{Pigeons.TestSwapper, Int64, Float64, Int64, Float64}" href="#Pigeons.swap_decision-Tuple{Pigeons.TestSwapper, Int64, Float64, Int64, Float64}"><code>Pigeons.swap_decision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap_decision(swapper, chain1, stat1, chain2, stat2)
</code></pre><p>See <a href="#Pigeons.TestSwapper"><code>TestSwapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/pair_swapper.jl#L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap_stat-Tuple{Any, Pigeons.Replica, Int64}" href="#Pigeons.swap_stat-Tuple{Any, Pigeons.Replica, Int64}"><code>Pigeons.swap_stat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap_stat(pair_swapper, replica, partner_chain)
</code></pre><p>By default, two sufficient statistics are computed and stored in the <a href="#Pigeons.SwapStat"><code>SwapStat</code></a> struct:</p><ul><li>The result of calling <a href="#Pigeons.log_unnormalized_ratio-Tuple{AbstractVector, Int64, Int64, Any}"><code>log_unnormalized_ratio()</code></a> on <a href="../interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a></li><li>A uniform number to coordinate the swap decision.</li></ul><p>This can be extended by dispatching on other <code>pair_swapper</code> types, with the  constraint that the returned sufficient statistics should satisfy <code>isbitstype()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/pair_swapper.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap_stat-Tuple{Pigeons.TestSwapper, Pigeons.Replica, Int64}" href="#Pigeons.swap_stat-Tuple{Pigeons.TestSwapper, Pigeons.Replica, Int64}"><code>Pigeons.swap_stat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap_stat(swapper, replica, partner_chain)
</code></pre><p>See <a href="#Pigeons.TestSwapper"><code>TestSwapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/pair_swapper.jl#L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.target_chains-Tuple{Any, Any}" href="#Pigeons.target_chains-Tuple{Any, Any}"><code>Pigeons.target_chains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">target_chains(swap_graphs, shared)
</code></pre><p>Given a <a href="../interfaces/#Pigeons.swap_graphs"><code>swap_graphs</code></a> and <a href="#Pigeons.Shared"><code>Shared</code></a>, return the set of chain(s) targetting the reference distribution. These are typically tractable in the sense that we can sample  i.i.d. from them. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/swap/swap_graphs.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.tempering_recorder_builders-Tuple{Any}" href="#Pigeons.tempering_recorder_builders-Tuple{Any}"><code>Pigeons.tempering_recorder_builders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">tempering_recorder_builders(tempering)
</code></pre><p>What information is needed to perform <a href="#Pigeons.adapt_tempering-Tuple{Any, Any}"><code>adapt_tempering</code></a>? Answer this by specifying an iterator containing <a href="../interfaces/#Pigeons.recorder_builder"><code>recorder_builder</code></a>&#39;s.  Return <code>[]</code> if none are needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/tempering/tempering.jl#L21">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.toy_mvn_target-Tuple{Int64}" href="#Pigeons.toy_mvn_target-Tuple{Int64}"><code>Pigeons.toy_mvn_target</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">toy_mvn_target(
    dim::Int64
) -&gt; Pigeons.ScaledPrecisionNormalPath
</code></pre><p>A toy multi-variate normal (mvn) target distribution used for testing.  Uses a specialized path, <a href="#Pigeons.ScaledPrecisionNormalPath"><code>ScaledPrecisionNormalPath</code></a>,  such that i.i.d. sampling is possible at all chains (via <a href="#Pigeons.ToyExplorer"><code>ToyExplorer</code></a>). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/targets/toy_mvn_target.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.transmit!-Union{Tuple{T}, Tuple{Pigeons.Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T" href="#Pigeons.transmit!-Union{Tuple{T}, Tuple{Pigeons.Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T"><code>Pigeons.transmit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transmit!(
    e,
    source_data,
    to_global_indices,
    write_received_data_here
)
</code></pre><p>Use MPI point-to-point communication to  permute the contents of <code>source_data</code> across MPI processes, writing the permuted data into  <code>write_received_data_here</code>.  The permutation is specified by the load balance in the input argument <code>e</code> as well as the  argument <code>to_global_indices</code>.</p><p>More precisely, assume the Vectors <code>source_data</code>, <code>to_global_indices</code>, and <code>write_received_data_here</code>  are all of the length specified in <code>my_load(e.load)</code>. </p><p>For each <code>i</code>, <code>source_data[i]</code> is sent to MPI process <code>p = find_process(e.load, g)</code>,  where <code>g = to_global_indices[i]</code> and  written into this <code>p</code> &#39;s <code>write_received_data_here[j]</code>, where <code>j = find_local_index(e.load, g)</code></p><p>See Entangler&#39;s comments regarding the requirement that all machines call transmit() the  same number of times and at logically related intervals. </p><p>Additionally, at each micro-iteration, we assume that  <code>{to_global_indices_p : p ranges over the different processes}</code> forms a partition of  <code>{1, ..., e.load.n_global_indices}</code> If ran in single-process mode, this &#39;partition property&#39; is checked;  if ran in multi-process, opportunistic checks will be made, namely when several entries in <code>to_global_indices</code>  lie in the same process, but systematic checks are not made for performance reasons. </p><p>We also assume <code>isbitstype(T) == true</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/Entangler.jl#L106">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.transmit-Union{Tuple{T}, Tuple{Pigeons.Entangler, AbstractVector{T}, AbstractVector{Int64}}} where T" href="#Pigeons.transmit-Union{Tuple{T}, Tuple{Pigeons.Entangler, AbstractVector{T}, AbstractVector{Int64}}} where T"><code>Pigeons.transmit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transmit(e, source_data, to_global_indices)
</code></pre><p>The same as <a href="#Pigeons.transmit!-Union{Tuple{T}, Tuple{Pigeons.Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T"><code>transmit!()</code></a> but instead of writing the result to an input argument, provide the result  as a returned <code>Vector</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/mpi_utils/Entangler.jl#L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.updateschedule-Tuple{Any, Int64}" href="#Pigeons.updateschedule-Tuple{Any, Int64}"><code>Pigeons.updateschedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateschedule(cumulativebarrier, N)
</code></pre><p>Update the annealing schedule. Given the cumulative communication barrier function in <code>cumulativebarrier</code>, find the optimal schedule of size <code>N</code>+1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/adaptation.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.winsorized_mean-Tuple{Any}" href="#Pigeons.winsorized_mean-Tuple{Any}"><code>Pigeons.winsorized_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">winsorized_mean(x; α)</code></pre><p>Compute the winsorized mean from an input <code>x</code>, which is assumed to be a vector of vectors.  <code>α</code> denotes the percentage of observations to winsorize at the bottom and the top  so that we use 1 - 2α observations and winsorize the rest.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/misc.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.winsorized_std-Tuple{Any}" href="#Pigeons.winsorized_std-Tuple{Any}"><code>Pigeons.winsorized_std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">winsorized_std(x; α)</code></pre><p>Compute the winsorized standard deviation. The parameters are the same  as those for <code>winsorized_mean()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/misc.jl#L23-L28">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.write_checkpoint-Tuple{Any, Any}" href="#Pigeons.write_checkpoint-Tuple{Any, Any}"><code>Pigeons.write_checkpoint</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">write_checkpoint(pt, reduced_recorders)
</code></pre><p>If <code>pt.inputs.checkpoint == true</code>, save a checkpoint under  <code>[pt.exec_folder]/[unique folder]/round=[x]/checkpoint</code>. </p><p>By default, <code>pt.exec_folder</code> is <code>results/all/[unique folder]</code>.</p><p>In an MPI context, each MPI process will write its local replicas,  while only one of the MPI processes will write the <a href="#Pigeons.Shared"><code>Shared</code></a>  and reduced <a href="../interfaces/#Pigeons.recorders"><code>recorders</code></a> data. Moreover, only one MPI process will  write once at the first round the <a href="#Pigeons.Inputs"><code>Inputs</code></a> data. </p><p>In cases where the sampled model contains large immutable data, consider using  <a href="#Pigeons.Immutable-Tuple{Any}"><code>Immutable()</code></a> to save disk space (Immutables will be written only by  one MPI process at the first round). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/pt/checkpoint.jl#L82-L99">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.@abstract-Tuple{}" href="#Pigeons.@abstract-Tuple{}"><code>Pigeons.@abstract</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">my_fct() = @abstract()</code></pre><p>Define an abstract function (i.e. which gives an error message if calling it  is attempted). </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/misc.jl#L103-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.@informal-Tuple{Symbol, Expr}" href="#Pigeons.@informal-Tuple{Symbol, Expr}"><code>Pigeons.@informal</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@informal name begin ... end</code></pre><p>Document an informal interface with provided <code>name</code>, and functions  specified in a <code>begin .. end</code> block. </p><p><code>@informal</code> will spit back the contents of the <code>begin .. end</code> block so  this macro can be essentially ignored at first read. </p><p>When building documentation, this allows us to use the  function <a href="#Pigeons.informal_doc-Tuple{Any, Module}"><code>informal_doc()</code></a> to automatically document the  informal interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/@informal.jl#L14-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.@weighted-Tuple{Any, Any}" href="#Pigeons.@weighted-Tuple{Any, Any}"><code>Pigeons.@weighted</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@weighted(w, x)</code></pre><p>Compute <code>w*x</code>, but if <code>w==0.0</code>, do not evaluate <code>x</code> and just return <code>w</code> (i.e. zero). Useful when x is computationally costly.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/2d3f81e6cbeec65f76e7aca446955497d12e756e/src/utils/misc.jl#L119-L124">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../interfaces/">« Interfaces</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Sunday 15 January 2023 02:01">Sunday 15 January 2023</span>. Using Julia version 1.8.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
