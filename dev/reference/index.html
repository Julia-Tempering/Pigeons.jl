<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Reference · Pigeons.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link rel="canonical" href="https://Julia-Tempering.github.io/Pigeons.jl/reference/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Pigeons.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Guide</a></li><li><a class="tocitem" href="../pt/">Parallel Tempering (PT)</a></li><li><a class="tocitem" href="../distributed/">Distributed PT</a></li><li><a class="tocitem" href="../.interfaces/">Interfaces</a></li><li class="is-active"><a class="tocitem" href>Reference</a><ul class="internal"><li><a class="tocitem" href="#Index"><span>Index</span></a></li><li><a class="tocitem" href="#Types-and-functions"><span>Types and functions</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Reference</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/main/docs/src/reference.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="../.interfaces/#Pigeons.log_potential"><code>Pigeons.log_potential</code></a></li><li><a href="../.interfaces/#Pigeons.log_potentials"><code>Pigeons.log_potentials</code></a></li><li><a href="../.interfaces/#Pigeons.pair_swapper"><code>Pigeons.pair_swapper</code></a></li><li><a href="../.interfaces/#Pigeons.path"><code>Pigeons.path</code></a></li><li><a href="../.interfaces/#Pigeons.recorder"><code>Pigeons.recorder</code></a></li><li><a href="../.interfaces/#Pigeons.recorders"><code>Pigeons.recorders</code></a></li><li><a href="../.interfaces/#Pigeons.replicas"><code>Pigeons.replicas</code></a></li><li><a href="../.interfaces/#Pigeons.state_initializer"><code>Pigeons.state_initializer</code></a></li><li><a href="../.interfaces/#Pigeons.swap_graph"><code>Pigeons.swap_graph</code></a></li><li><a href="#Pigeons.EntangledReplicas"><code>Pigeons.EntangledReplicas</code></a></li><li><a href="#Pigeons.Entangler"><code>Pigeons.Entangler</code></a></li><li><a href="#Pigeons.LoadBalance"><code>Pigeons.LoadBalance</code></a></li><li><a href="#Pigeons.PermutedDistributedArray"><code>Pigeons.PermutedDistributedArray</code></a></li><li><a href="#Pigeons.Replica"><code>Pigeons.Replica</code></a></li><li><a href="#Pigeons.ScaledPrecisionNormalPath"><code>Pigeons.ScaledPrecisionNormalPath</code></a></li><li><a href="#Pigeons.ScaledPrecisionNormalPath-Tuple{Int64}"><code>Pigeons.ScaledPrecisionNormalPath</code></a></li><li><a href="#Pigeons.Schedule-Tuple{Int64}"><code>Pigeons.Schedule</code></a></li><li><a href="#Pigeons.Schedule"><code>Pigeons.Schedule</code></a></li><li><a href="#Pigeons.Schedule-Tuple{Int64, Any}"><code>Pigeons.Schedule</code></a></li><li><a href="#Pigeons.SwapStat"><code>Pigeons.SwapStat</code></a></li><li><a href="#Pigeons.TestSwapper"><code>Pigeons.TestSwapper</code></a></li><li><a href="#Pigeons.TranslatedNormalPath"><code>Pigeons.TranslatedNormalPath</code></a></li><li><a href="#Pigeons.NRPT-Tuple{Any, Any, Array{Vector{T}, 1} where T&lt;:Real, Int64, Int64}"><code>Pigeons.NRPT</code></a></li><li><a href="#Pigeons.acceptanceprobability-Tuple{Any, Any, Any}"><code>Pigeons.acceptanceprobability</code></a></li><li><a href="#Pigeons.all_reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Entangler}} where T"><code>Pigeons.all_reduce_deterministically</code></a></li><li><a href="#Pigeons.analytic_cumulativebarrier-Tuple{ScaledPrecisionNormalPath}"><code>Pigeons.analytic_cumulativebarrier</code></a></li><li><a href="#Pigeons.combine-Tuple{Any, Any}"><code>Pigeons.combine</code></a></li><li><a href="#Pigeons.communicationbarrier-Tuple{AbstractVector, AbstractVector}"><code>Pigeons.communicationbarrier</code></a></li><li><a href="#Pigeons.communicator-Tuple{Any}"><code>Pigeons.communicator</code></a></li><li><a href="#Pigeons.computeetas-Tuple{Any, Any}"><code>Pigeons.computeetas</code></a></li><li><a href="#Pigeons.create_entangled_replicas"><code>Pigeons.create_entangled_replicas</code></a></li><li><a href="#Pigeons.create_path"><code>Pigeons.create_path</code></a></li><li><a href="#Pigeons.create_vector_replicas"><code>Pigeons.create_vector_replicas</code></a></li><li><a href="#Pigeons.custom_recorders-Tuple{Set{Symbol}}"><code>Pigeons.custom_recorders</code></a></li><li><a href="#Pigeons.default_recorders-Tuple{}"><code>Pigeons.default_recorders</code></a></li><li><a href="#Pigeons.deo-Tuple{Any, Any, Any, Any, Any, Any, Int64, Int64, Int64, Any, Any, Any, Any, Bool, Any, Int64}"><code>Pigeons.deo</code></a></li><li><a href="#Pigeons.deo-Tuple{Int64, Int64}"><code>Pigeons.deo</code></a></li><li><a href="#Pigeons.deoscan-NTuple{15, Any}"><code>Pigeons.deoscan</code></a></li><li><a href="#Pigeons.discretize-Tuple{Any, Schedule}"><code>Pigeons.discretize</code></a></li><li><a href="#Pigeons.entangler-Tuple{Any}"><code>Pigeons.entangler</code></a></li><li><a href="#Pigeons.find_global_index-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_global_index</code></a></li><li><a href="#Pigeons.find_local_index-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_local_index</code></a></li><li><a href="#Pigeons.find_process-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_process</code></a></li><li><a href="#Pigeons.index_process_plot-Tuple{Any}"><code>Pigeons.index_process_plot</code></a></li><li><a href="#Pigeons.informal_doc-Tuple{Any, Module}"><code>Pigeons.informal_doc</code></a></li><li><a href="#Pigeons.initialization-Tuple{Any, SplittableRandoms.SplittableRandom, Int64}"><code>Pigeons.initialization</code></a></li><li><a href="#Pigeons.interpolate-Tuple{Any, Any}"><code>Pigeons.interpolate</code></a></li><li><a href="#Pigeons.load-Tuple{Any}"><code>Pigeons.load</code></a></li><li><a href="#Pigeons.local_exploration-NTuple{9, Any}"><code>Pigeons.local_exploration</code></a></li><li><a href="#Pigeons.locals-Tuple{Any}"><code>Pigeons.locals</code></a></li><li><a href="#Pigeons.log_unnormalized_ratio-Tuple{AbstractVector, Int64, Int64, Any}"><code>Pigeons.log_unnormalized_ratio</code></a></li><li><a href="#Pigeons.log_unnormalized_ratio-Tuple{Any, Int64, Int64, Any}"><code>Pigeons.log_unnormalized_ratio</code></a></li><li><a href="#Pigeons.lognormalizingconstant-Tuple{Any, Any}"><code>Pigeons.lognormalizingconstant</code></a></li><li><a href="#Pigeons.my_global_indices-Tuple{Pigeons.LoadBalance}"><code>Pigeons.my_global_indices</code></a></li><li><a href="#Pigeons.my_load-Tuple{Pigeons.LoadBalance}"><code>Pigeons.my_load</code></a></li><li><a href="#Pigeons.n_chains_global-Tuple{Any}"><code>Pigeons.n_chains_global</code></a></li><li><a href="#Pigeons.one_per_host-Tuple{Any}"><code>Pigeons.one_per_host</code></a></li><li><a href="#Pigeons.partner_chain-Tuple{Any, Int64}"><code>Pigeons.partner_chain</code></a></li><li><a href="#Pigeons.permuted_get-Union{Tuple{T}, Tuple{PermutedDistributedArray{T}, AbstractVector{Int64}}} where T"><code>Pigeons.permuted_get</code></a></li><li><a href="#Pigeons.permuted_set!-Union{Tuple{T}, Tuple{PermutedDistributedArray{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>Pigeons.permuted_set!</code></a></li><li><a href="#Pigeons.record!-Tuple{OnlineStatsBase.OnlineStat, Any}"><code>Pigeons.record!</code></a></li><li><a href="#Pigeons.record!-Tuple{Any, Any}"><code>Pigeons.record!</code></a></li><li><a href="#Pigeons.record!-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K, Vector{V}}, Tuple{K, V}}} where {K, V}"><code>Pigeons.record!</code></a></li><li><a href="#Pigeons.record_if_requested!-Tuple{NamedTuple, Any, Any}"><code>Pigeons.record_if_requested!</code></a></li><li><a href="#Pigeons.record_swap_stats!-Tuple{Any, Any, Int64, Any, Int64, Any}"><code>Pigeons.record_swap_stats!</code></a></li><li><a href="#Pigeons.record_swap_stats!-Tuple{Pigeons.TestSwapper, Any, Int64, Any, Int64, Any}"><code>Pigeons.record_swap_stats!</code></a></li><li><a href="#Pigeons.recorder_keys-Tuple{Vararg{Symbol}}"><code>Pigeons.recorder_keys</code></a></li><li><a href="#Pigeons.reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Entangler}} where T"><code>Pigeons.reduce_deterministically</code></a></li><li><a href="#Pigeons.reduced_recorders-Tuple{Any}"><code>Pigeons.reduced_recorders</code></a></li><li><a href="#Pigeons.reference_chains-Tuple{Any}"><code>Pigeons.reference_chains</code></a></li><li><a href="#Pigeons.restarts-Tuple{Any}"><code>Pigeons.restarts</code></a></li><li><a href="#Pigeons.roundtrip-Tuple{Any}"><code>Pigeons.roundtrip</code></a></li><li><a href="#Pigeons.scaled_normal_example-Tuple{Any, Any}"><code>Pigeons.scaled_normal_example</code></a></li><li><a href="#Pigeons.setkernels-Tuple{Any, Any}"><code>Pigeons.setkernels</code></a></li><li><a href="#Pigeons.single_process_load-Tuple{Any}"><code>Pigeons.single_process_load</code></a></li><li><a href="#Pigeons.slice_accept-Tuple{SS, Any, Vector{Float64}, Any, Float64, Float64, Float64, Int64}"><code>Pigeons.slice_accept</code></a></li><li><a href="#Pigeons.slice_double-Tuple{SS, Any, Vector{Float64}, Float64, Int64}"><code>Pigeons.slice_double</code></a></li><li><a href="#Pigeons.slice_sample-Tuple{SS, Vector{Float64}, Int64}"><code>Pigeons.slice_sample</code></a></li><li><a href="#Pigeons.slice_shrink-Tuple{SS, Any, Vector{Float64}, Float64, Float64, Float64, Int64}"><code>Pigeons.slice_shrink</code></a></li><li><a href="#Pigeons.split_slice-Tuple{UnitRange, Any}"><code>Pigeons.split_slice</code></a></li><li><a href="#Pigeons.swap!-Tuple{Any, Any, Any}"><code>Pigeons.swap!</code></a></li><li><a href="#Pigeons.swap!-Tuple{Any, EntangledReplicas, Any}"><code>Pigeons.swap!</code></a></li><li><a href="#Pigeons.swap!-Union{Tuple{R}, Tuple{Any, Vector{R}, Any}} where R"><code>Pigeons.swap!</code></a></li><li><a href="#Pigeons.swap_decision-Tuple{Pigeons.TestSwapper, Int64, Float64, Int64, Float64}"><code>Pigeons.swap_decision</code></a></li><li><a href="#Pigeons.swap_decision-Tuple{Any, Int64, Any, Int64, Any}"><code>Pigeons.swap_decision</code></a></li><li><a href="#Pigeons.swap_stat-Tuple{Pigeons.TestSwapper, Replica, Int64}"><code>Pigeons.swap_stat</code></a></li><li><a href="#Pigeons.swap_stat-Tuple{Any, Replica, Int64}"><code>Pigeons.swap_stat</code></a></li><li><a href="#Pigeons.target_chains-Tuple{Any}"><code>Pigeons.target_chains</code></a></li><li><a href="#Pigeons.transmit-Union{Tuple{T}, Tuple{Entangler, AbstractVector{T}, AbstractVector{Int64}}} where T"><code>Pigeons.transmit</code></a></li><li><a href="#Pigeons.transmit!-Union{Tuple{T}, Tuple{Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T"><code>Pigeons.transmit!</code></a></li><li><a href="#Pigeons.updateschedule-Tuple{Any, Int64}"><code>Pigeons.updateschedule</code></a></li><li><a href="#Pigeons.winsorized_mean-Tuple{Any}"><code>Pigeons.winsorized_mean</code></a></li><li><a href="#Pigeons.winsorized_std-Tuple{Any}"><code>Pigeons.winsorized_std</code></a></li><li><a href="#Pigeons.@informal-Tuple{Symbol, Expr}"><code>Pigeons.@informal</code></a></li></ul><h2 id="Types-and-functions"><a class="docs-heading-anchor" href="#Types-and-functions">Types and functions</a><a id="Types-and-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Types-and-functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Pigeons.EntangledReplicas" href="#Pigeons.EntangledReplicas"><code>Pigeons.EntangledReplicas</code></a> — <span class="docstring-category">Type</span></header><section><div><p>An implementation of <a href="../.interfaces/#Pigeons.replicas"><code>replicas</code></a> for distributed PT.  Contains:</p><ul><li><code>locals</code></li></ul><p>: The subset of replicas hosted in this process</p><ul><li><code>chain_to_replica_global_indices</code></li></ul><p>: A specialized distributed array that     maps chain indices to replica indices (global indices).     This corresponds to the mapping <span>$\boldsymbol{j}$</span> in line 2 of     Algorithm 5 in <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al, 2021</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/EntangledReplicas.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Entangler" href="#Pigeons.Entangler"><code>Pigeons.Entangler</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Assume all the MPI processes linked by this communicator  will all call the <em>key operations</em> listed below the same number of times  in their lifetime, at logically related occasions (e.g. a set  number of times per iterations for algorithms running the  same number of iterations). We call these &#39;occasions&#39; a micro-iteration.</p><p>This datastructure keeps track internally of appropriate unique  tags to coordinate the communication between MPI processes  without having to do any explicit synchnonization. </p><p>This struct contains:</p><ul><li><code>communicator</code></li></ul><p>: An MPI <code>Comm</code> object (or nothing if a single process is involved).</p><ul><li><code>load</code></li></ul><p>: How a set of tasks or &quot;global indices&quot; are distributed across processes.</p><ul><li><code>current_received_bits</code></li></ul><p>: An internal datastructure used during MPI calls.</p><ul><li><code>n_transmits</code></li></ul><p>: The current micro-iteration.</p><p>The <em>key operations</em> supported:</p><ul><li><a href="#Pigeons.transmit-Union{Tuple{T}, Tuple{Entangler, AbstractVector{T}, AbstractVector{Int64}}} where T"><code>transmit()</code></a> and <a href="#Pigeons.transmit!-Union{Tuple{T}, Tuple{Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T"><code>transmit!()</code></a>: encapsulates    pairwise communications in which each MPI process is holding     a <code>Vector</code>, the elements of which is to be permuted across the processes.</li><li><a href="#Pigeons.all_reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Entangler}} where T"><code>all_reduce_deterministically</code></a> and <a href="#Pigeons.reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Entangler}} where T"><code>reduce_deterministically</code></a>,    to perform MPI collective reduction while maintaining the    Parallelism Invariance property.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/Entanglement.jl#L1-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.LoadBalance" href="#Pigeons.LoadBalance"><code>Pigeons.LoadBalance</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Split a list of indices across processes.  These indices are denoted <span>$1, 2, .., N$</span>. They are usually some kind of task,  for example in the context of parallel tempering,  two kinds of tasks arise:</p><ul><li>in <code>replicas.state</code>, task <span>$i$</span> consists in keeping track of the state of    replica <span>$i$</span>.</li><li>in <code>replicas.chain_to_replica_global_indices</code>, task <span>$i$</span> consists in    storing which replica index corresponds to chain <span>$i$</span>.</li></ul><p>One such task index is called a <code>global_index</code>. </p><p>LoadBalance splits the global indices among <code>n_processes</code>. LoadBalance  is constructed so that the difference in the number of global indices  a process is responsible of (its &quot;load&quot;)  is at most one.</p><p>A <code>LoadBalance</code> contains:</p><ul><li><code>my_process_index</code></li></ul><p>: A unique index for this process.     We use 1-indexed,     i.e. hide MPI&#39;s 0-indexed ranks.</p><ul><li><code>n_processes</code></li></ul><p>: Total number of processes involved.</p><ul><li><code>n_global_indices</code></li></ul><p>: The total number of global indices shared between all the processes.</p><p>The set {1, 2, .., <a href="#Pigeons.load-Tuple{Any}"><code>load()</code></a>} is called a set of local indices.  A local index indexes a slice in {1, 2, ..., <code>n_global_indices</code>}.  Collectively over the <code>n_processes</code>, these slices form a partition of  the global indices.</p><p>Key functions to utilize a LoadBalance struct:</p><ul><li><a href="#Pigeons.my_global_indices-Tuple{Pigeons.LoadBalance}"><code>my_global_indices()</code></a></li><li><a href="#Pigeons.find_process-Tuple{Pigeons.LoadBalance, Int64}"><code>find_process()</code></a></li><li><a href="#Pigeons.find_local_index-Tuple{Pigeons.LoadBalance, Int64}"><code>find_local_index()</code></a></li><li><a href="#Pigeons.my_load-Tuple{Pigeons.LoadBalance}"><code>my_load()</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/LoadBalance.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.PermutedDistributedArray" href="#Pigeons.PermutedDistributedArray"><code>Pigeons.PermutedDistributedArray</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A distributed array making special assumptions on how  it will be accessed and written to.  The indices of this distributed array correspond to the  notion of &quot;global indices&quot; defined in <a href="#Pigeons.LoadBalance"><code>LoadBalance</code></a>.  Several MPI processes cooperate, each processing storing  data for a slice of this distributed array. </p><p>We make the following assumptions:</p><ul><li><p>Each MPI process will set/get    entries the same number of times in their lifetime, at    logically related episodes (e.g. a set    number of times per iterations for algorithms running the    same number of iterations).    These episodes are called micro-iteration as in <a href="#Pigeons.Entangler"><code>Entangler</code></a>,    which this datastructure is built on.</p></li><li><p>Moreover, at each time all process perform a get or a set,    we assume that each global index is manipulated by exactly one    process (i.e. an implicit permutation of the global indices).</p></li></ul><p>We use these assumptions to achieve  read/write costs that are  near-constant in the number of machines participating. </p><p>This struct contains:</p><ul><li><code>local_data</code></li></ul><p>: The slice of the distributed array maintained by this MPI process.</p><ul><li><code>entangler</code></li></ul><p>: An <a href="#Pigeons.Entangler"><code>Entangler</code></a> used to coordinate communication.</p><p>The operations supported are:</p><ul><li><a href="#Pigeons.permuted_get-Union{Tuple{T}, Tuple{PermutedDistributedArray{T}, AbstractVector{Int64}}} where T"><code>permuted_get()</code></a></li><li><a href="#Pigeons.permuted_set!-Union{Tuple{T}, Tuple{PermutedDistributedArray{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>permuted_set!()</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/PermutedDistributedArray.jl#L1-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Replica" href="#Pigeons.Replica"><code>Pigeons.Replica</code></a> — <span class="docstring-category">Type</span></header><section><div><p>One of the <span>$N$</span> components that forms the state maintained by a PT algorithm. A Replica contains:</p><ul><li><code>state</code></li></ul><p>:  Configuration in the state space.</p><ul><li><code>chain</code></li></ul><p>:  The index of the distribution currently associated with this replica, modified during swaps.</p><ul><li><code>rng</code></li></ul><p>:  Random operations involving this state should use only this random number generator.</p><ul><li><code>recorders</code></li></ul><p>: Records statistics. Each replica carries its own for thread safety/distribution, to be reduced to access.</p><ul><li><code>replica_index</code></li></ul><p>: A global id associated with this replica.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/Replica.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.ScaledPrecisionNormalPath" href="#Pigeons.ScaledPrecisionNormalPath"><code>Pigeons.ScaledPrecisionNormalPath</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <a href="../.interfaces/#Pigeons.path"><code>path</code></a> of zero-mean normals for testing; contains:</p><ul><li><code>precision0</code></li></ul><p>: Precision parameter of the reference.</p><ul><li><code>precision1</code></li></ul><p>: Precision parameter of the target.</p><ul><li><code>dim</code></li></ul><p>: Dimensionality.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/path_implementations.jl#L50-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.ScaledPrecisionNormalPath-Tuple{Int64}" href="#Pigeons.ScaledPrecisionNormalPath-Tuple{Int64}"><code>Pigeons.ScaledPrecisionNormalPath</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ScaledPrecisionNormalPath(
    dim::Int64
) -&gt; ScaledPrecisionNormalPath
</code></pre><p>Toy path for testing: see section I.4.1 in Syed et al 2021. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/path_implementations.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Schedule" href="#Pigeons.Schedule"><code>Pigeons.Schedule</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A partition of [0, 1] encoded by monotonically increasing grid points  starting at zero and ending at one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/discretize.jl#L1-L4">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Schedule-Tuple{Int64, Any}" href="#Pigeons.Schedule-Tuple{Int64, Any}"><code>Pigeons.Schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Schedule(
    n_chains::Int64,
    cumulativebarrier
) -&gt; Schedule{Vector{Float64}}
</code></pre><p>Create a <a href="#Pigeons.Schedule"><code>Schedule</code></a> with <code>n_chains</code> grid points computed using Algorithm 2 in  Syed et al, 2021. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/discretize.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.Schedule-Tuple{Int64}" href="#Pigeons.Schedule-Tuple{Int64}"><code>Pigeons.Schedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Schedule(
    n_chains::Int64
) -&gt; Schedule{StepRangeLen{Float64, Base.TwicePrecision{Float64}, Base.TwicePrecision{Float64}, Int64}}
</code></pre><p>Create a <a href="#Pigeons.Schedule"><code>Schedule</code></a> with <code>n_chains</code> equally spaced grid points.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/discretize.jl#L19">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.SwapStat" href="#Pigeons.SwapStat"><code>Pigeons.SwapStat</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Default statistics exchanged by a pair of chains in the process of proposing a swap:</p><ul><li><p><code>log_ratio</code></p></li><li><p><code>uniform</code></p></li></ul><p>See <a href="#Pigeons.swap_stat-Tuple{Any, Replica, Int64}"><code>swap_stat()</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/pair_swapper.jl#L1-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.TestSwapper" href="#Pigeons.TestSwapper"><code>Pigeons.TestSwapper</code></a> — <span class="docstring-category">Type</span></header><section><div><p>For testing/benchmarking purposes, a simple  <a href="../.interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a> where all swaps have equal  acceptance probability. </p><p>Could also be used to warm-start swap connections  during exploration phase by setting that  constant probability to zero.  </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/pair_swapper.jl#L93-L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.TranslatedNormalPath" href="#Pigeons.TranslatedNormalPath"><code>Pigeons.TranslatedNormalPath</code></a> — <span class="docstring-category">Type</span></header><section><div><ul><li><code>mean</code></li></ul><p>: Path between a MVN with mean zero at one end point and given <code>mean</code> at the other.</p><p>Toy path for testing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/path_implementations.jl#L40">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.NRPT-Tuple{Any, Any, Array{Vector{T}, 1} where T&lt;:Real, Int64, Int64}" href="#Pigeons.NRPT-Tuple{Any, Any, Array{Vector{T}, 1} where T&lt;:Real, Int64, Int64}"><code>Pigeons.NRPT</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">NRPT(V_0, V_1, initial_state, ntotal, N)</code></pre><p>Non-reversible parallel tempering (NRPT).</p><p><strong>Arguments</strong></p><ul><li><code>potential</code>: Function with three arguments (x, η, params) that returns a &#39;double&#39;.  &#39;x&#39; is the point at which the log-density V<em>0(x; params=params) * η[1] + V</em>1(x) * η[2] is evaluated,  where V<em>0 is the negative log density of the reference and V</em>1 is the negative  log density of the target.</li><li><code>initial_state</code>: Matrix of initial states for all N+1 chains. Dimensions: (N+1) x (dim_x).</li><li><code>ntotal</code>: Total number of scans/iterations.</li><li><code>N</code>: The total number of chains is N+1.</li><li><code>optimreference</code>: Whether the reference distribution is to be optimized.</li><li><code>maxround</code>: Maximum number of rounds for tuning.</li><li><code>fulltrajectory</code>: Controls whether to keep track of all &#39;states&#39;, &#39;indices&#39;, &#39;energies&#39;, and &#39;lifts&#39;.</li><li><code>ϕ</code>: (Partially removed. Useful for constructing non-linear paths.)</li><li><code>resolution</code>: Resolution of the output for the estimates of the local communication barrier. </li><li><code>prior_sampler</code>: User may supply an efficient sampler that can obtain   samples from the <em>prior</em> / original reference distribution.</li><li><code>optimreference_start</code>: On which tuning round to start optimizing the reference distribution.</li><li><code>full_covariance</code>: Controls whether to use a mean-field approximation for the modified   reference (false) or a full covariance matrix (true)</li><li><code>winsorize</code>: Whether or not to use a winsorized/trimmed mean when estimating </li></ul><p>the parameters of the variational reference</p><ul><li><code>two_references</code>: Whether to run two PT chains in parallel with two different references:   prior and variational reference. Note that with this setting there are 2*(N+1) chains in total.</li><li><code>modref_means_start</code>: Starting values for modref_means</li><li><code>modref_stds_start</code>: Starting values for modref_stds</li><li><code>n_explore</code>: Number of exploration steps to take before considering a communication swap</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/NRPT.jl#L27-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.acceptanceprobability-Tuple{Any, Any, Any}" href="#Pigeons.acceptanceprobability-Tuple{Any, Any, Any}"><code>Pigeons.acceptanceprobability</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">acceptanceprobability(newenergy, newenergy1, newenergy2)</code></pre><p>Compute acceptance probabilities for communication moves.  <code>newenergy</code> inputs are lists of numbers. </p><p><strong>Arguments</strong></p><ul><li><code>newenergy</code>: -log([π<em>β</em>0(x^0), π<em>β</em>1(x^1), ..., π<em>β</em>N(x^N)]) : length N+1</li><li><code>newenergy1</code>: -log([π<em>β</em>0(x^1), π<em>β</em>1(x^2), ..., π<em>β</em>{N-1}(x^N)]) : length N</li><li><code>newenergy2</code>: -log([π<em>β</em>1(x^0), π<em>β</em>2(x^1), ..., π<em>β</em>N(x^{N-1})]) : length N</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/acceptance.jl#L1-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.all_reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Entangler}} where T" href="#Pigeons.all_reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Entangler}} where T"><code>Pigeons.all_reduce_deterministically</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Same as <a href="#Pigeons.reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Entangler}} where T"><code>reduce_deterministically()</code></a> except that the result at the root of the  tree is then broadcast to all machines so that the output of <code>all_reduce_deterministically()</code>  is the root of the reduction tree for all MPI processes involved. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/Entanglement.jl#L256">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.analytic_cumulativebarrier-Tuple{ScaledPrecisionNormalPath}" href="#Pigeons.analytic_cumulativebarrier-Tuple{ScaledPrecisionNormalPath}"><code>Pigeons.analytic_cumulativebarrier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">analytic_cumulativebarrier(
    path::ScaledPrecisionNormalPath
) -&gt; Pigeons.var&quot;#cumulativebarrier#30&quot;{ScaledPrecisionNormalPath, Float64}
</code></pre><p>Known cumulative barrier used for testing,  from <a href="https://aip.scitation.org/doi/10.1063/1.1644093">Predescu et al., 2003</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/path_implementations.jl#L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.combine-Tuple{Any, Any}" href="#Pigeons.combine-Tuple{Any, Any}"><code>Pigeons.combine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">combine(recorder1, recorder2) -&gt; Any
</code></pre><p>Combine the two provided <a href="../.interfaces/#Pigeons.recorder"><code>recorder</code></a> objects. </p><p>By default, call <code>Base.merge()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/recorder.jl#L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.communicationbarrier-Tuple{AbstractVector, AbstractVector}" href="#Pigeons.communicationbarrier-Tuple{AbstractVector, AbstractVector}"><code>Pigeons.communicationbarrier</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">communicationbarrier(
    rejection::AbstractVector,
    schedule::AbstractVector
) -&gt; NamedTuple{(:localbarrier, :cumulativebarrier, :globalbarrier), _A} where _A&lt;:Tuple{Pigeons.var&quot;#localbarrier#34&quot;, Pigeons.var&quot;#cumulativebarrier#33&quot;, Any}
</code></pre><p>Compute the local communication barrier and cumulative barrier functions from the  <code>rejection</code> rates and the current annealing <code>schedule</code>. The estimation of the barriers  is based on Fritsch-Carlson monotonic interpolation.</p><p>Returns a <code>NamedTuple</code> with fields:</p><ul><li><code>localbarrier</code></li><li><code>cumulativebarrier</code></li><li><code>globalbarrier</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/adaptation.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.communicator-Tuple{Any}" href="#Pigeons.communicator-Tuple{Any}"><code>Pigeons.communicator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">communicator(replicas)
</code></pre><p>Return the <a href="../.interfaces/#Pigeons.replicas"><code>replicas</code></a>&#39;s <code>MPI.Comm</code> or <code>nothing</code> if no MPI needed</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/replicas.jl#L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.computeetas-Tuple{Any, Any}" href="#Pigeons.computeetas-Tuple{Any, Any}"><code>Pigeons.computeetas</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">computeetas(ϕ, β) -&gt; Any
</code></pre><p>Compute the <code>etas</code> matrix given <code>ϕ</code>, which is an Array(K - 1, 2) containing  knot parameters, and <code>β</code>, a vector of <code>N</code>+1 schedules. For linear paths,  the function returns an (N+1)x2 matrix with entries 1-β in the first column  and β in the second column. (This function is useful for those wishing to consider non-linear paths. However, full support is provided only for linear paths at  the moment.) </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/utils.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_entangled_replicas" href="#Pigeons.create_entangled_replicas"><code>Pigeons.create_entangled_replicas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_entangled_replicas(
    n_chains::Int64,
    state_initializer,
    rng::SplittableRandoms.SplittableRandom
) -&gt; EntangledReplicas
create_entangled_replicas(
    n_chains::Int64,
    state_initializer,
    rng::SplittableRandoms.SplittableRandom,
    useMPI::Bool
) -&gt; EntangledReplicas
create_entangled_replicas(
    n_chains::Int64,
    state_initializer,
    rng::SplittableRandoms.SplittableRandom,
    useMPI::Bool,
    recorder_keys::Set{Symbol}
) -&gt; EntangledReplicas
</code></pre><p>Create distributed replicas. The argument <code>useMPI = false</code> is only for debugging purpose. See also <a href="../.interfaces/#Pigeons.state_initializer"><code>state_initializer</code></a>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/EntangledReplicas.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_path" href="#Pigeons.create_path"><code>Pigeons.create_path</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_path(ref, target) -&gt; Any
create_path(ref, target, interpolator) -&gt; Any
</code></pre><p>Given a reference <a href="../.interfaces/#Pigeons.log_potential"><code>log_potential</code></a> and a target <a href="../.interfaces/#Pigeons.log_potential"><code>log_potential</code></a>,  return a <a href="../.interfaces/#Pigeons.path"><code>path</code></a> interpolating between the two. </p><p>By default, the <code>interpolator</code> is a <code>LinearInterpolator</code>, i.e.  standard annealing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/path_implementations.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.create_vector_replicas" href="#Pigeons.create_vector_replicas"><code>Pigeons.create_vector_replicas</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">create_vector_replicas(
    n_chains::Int64,
    state_initializer,
    rng::SplittableRandoms.SplittableRandom
) -&gt; Any
create_vector_replicas(
    n_chains::Int64,
    state_initializer,
    rng::SplittableRandoms.SplittableRandom,
    recorder_keys::Set{Symbol}
) -&gt; Any
</code></pre><p>Create <a href="../.interfaces/#Pigeons.replicas"><code>replicas</code></a> when distributed computing is not needed.  See also <a href="../.interfaces/#Pigeons.state_initializer"><code>state_initializer</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/replicas.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.custom_recorders-Tuple{Set{Symbol}}" href="#Pigeons.custom_recorders-Tuple{Set{Symbol}}"><code>Pigeons.custom_recorders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">custom_recorders(
    recorder_keys::Set{Symbol}
) -&gt; Union{NamedTuple{(:swap_acceptance_pr,), Tuple{OnlineStatsBase.GroupBy{Tuple{Int64, Int64}, Number, OnlineStatsBase.Mean{Float64, OnlineStatsBase.EqualWeight}}}}, NamedTuple{(:swap_acceptance_pr, :index_process), Tuple{OnlineStatsBase.GroupBy{Tuple{Int64, Int64}, Number, OnlineStatsBase.Mean{Float64, OnlineStatsBase.EqualWeight}}, Dict{Int64, Vector{Int64}}}}}
</code></pre><p>This returns <a href="#Pigeons.default_recorders-Tuple{}"><code>default_recorders()</code></a> plus those  provided in the <code>recorder_keys</code>. </p><p>See also <a href="#Pigeons.recorder_keys-Tuple{Vararg{Symbol}}"><code>recorder_keys</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/recorders.jl#L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.default_recorders-Tuple{}" href="#Pigeons.default_recorders-Tuple{}"><code>Pigeons.default_recorders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">default_recorders(

) -&gt; NamedTuple{(:swap_acceptance_pr,), Tuple{OnlineStatsBase.GroupBy{Tuple{Int64, Int64}, Number, OnlineStatsBase.Mean{Float64, OnlineStatsBase.EqualWeight}}}}
</code></pre><p>Basic, constant-memory <a href="../.interfaces/#Pigeons.recorders"><code>recorders</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/recorders.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.deo-Tuple{Any, Any, Any, Any, Any, Any, Int64, Int64, Int64, Any, Any, Any, Any, Bool, Any, Int64}" href="#Pigeons.deo-Tuple{Any, Any, Any, Any, Any, Any, Int64, Int64, Int64, Any, Any, Any, Any, Bool, Any, Int64}"><code>Pigeons.deo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deo(potential, initial_state, initial_index, initial_lift, schedule, ϕ, 
    nscan, N, resolution, optimreference_round, modref_means, modref_stds, modref_covs, 
    full_covariance, prior_sampler, n_explore)</code></pre><p>Deterministic even-odd parallel tempering (DEO/NRPT).</p><p><strong>Arguments</strong></p><ul><li><code>potential</code>: Function as in NRPT, but with only two arguments: x and η</li><li><code>initial_state</code>: Starting state, as in NRPT. Input is of size: N+1 [ dim_x ]</li><li><code>initial_index</code>: Starting indices</li><li><code>initial_lift</code>: Starting lift</li><li><code>schedule</code>: Annealing schedule</li><li><code>ϕ</code>: As in NRPT</li><li><code>nscan</code>: Number of scans to use</li><li><code>N</code>: As in NRPT</li><li><code>resolution</code>: As in NRPT</li><li><code>optimreference_round</code>: As in NRPT</li><li><code>modref_means</code></li><li><code>modref_stds</code></li><li><code>prior_sample</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/deo.jl#L1-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.deo-Tuple{Int64, Int64}" href="#Pigeons.deo-Tuple{Int64, Int64}"><code>Pigeons.deo</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deo(
    n_chains::Int64,
    current_iteration::Int64
) -&gt; Pigeons.OddEven
</code></pre><p>Implements the Deterministic Even Odd (DEO) scheme proposed in <a href="https://www.sciencedirect.com/science/article/pii/S0009261401000550">Okabe, 2001</a> and analyzed in <a href="https://rss.onlinelibrary.wiley.com/doi/10.1111/rssb.12464">Syed et al., 2021</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/swap_graph.jl#L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.deoscan-NTuple{15, Any}" href="#Pigeons.deoscan-NTuple{15, Any}"><code>Pigeons.deoscan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">deoscan(potential, state, index, lift, etas, n, N, kernels, 
    optimreference_round, modref_means, modref_stds, modref_covs, full_covariance, 
    prior_sampler, n_explore)</code></pre><p>Perform one DEO scan (local exploration + communication). Arguments are  similar to those for <code>deo()</code>. Note that <code>state</code> is the state from the <strong>one</strong> previous  scan, which is of size N+1[dim_x].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/deo.jl#L95-L103">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.discretize-Tuple{Any, Schedule}" href="#Pigeons.discretize-Tuple{Any, Schedule}"><code>Pigeons.discretize</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">discretize(path, betas::Schedule) -&gt; Any
</code></pre><p>Create <a href="../.interfaces/#Pigeons.log_potentials"><code>log_potentials</code></a> from a <a href="../.interfaces/#Pigeons.path"><code>path</code></a> by interpolating the  path at each grid point specified in the <a href="#Pigeons.Schedule"><code>Schedule</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/discretize.jl#L37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.entangler-Tuple{Any}" href="#Pigeons.entangler-Tuple{Any}"><code>Pigeons.entangler</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">entangler(replicas) -&gt; Entangler
</code></pre><p>Return the <a href="../.interfaces/#Pigeons.replicas"><code>replicas</code></a>&#39;s <a href="#Pigeons.Entangler"><code>Entangler</code></a> (possibly a no-communication Entangler if a single process is involved)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/replicas.jl#L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.find_global_index-Tuple{Pigeons.LoadBalance, Int64}" href="#Pigeons.find_global_index-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_global_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_global_index(
    lb::Pigeons.LoadBalance,
    local_idx::Int64
) -&gt; Int64
</code></pre><p>Find the global index corresponding to the given <code>local_index</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/LoadBalance.jl#L101">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.find_local_index-Tuple{Pigeons.LoadBalance, Int64}" href="#Pigeons.find_local_index-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_local_index</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_local_index(
    lb::Pigeons.LoadBalance,
    global_idx::Int64
) -&gt; Int64
</code></pre><p>Find the local index corresponding to the given <code>global_index</code>.  Assumes the given <code>global_index</code> is one of this process&#39;. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/LoadBalance.jl#L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.find_process-Tuple{Pigeons.LoadBalance, Int64}" href="#Pigeons.find_process-Tuple{Pigeons.LoadBalance, Int64}"><code>Pigeons.find_process</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_process(
    lb::Pigeons.LoadBalance,
    global_idx::Int64
) -&gt; Int64
</code></pre><p>Find the process id (1-indexed) responsible for the given <code>global_idx</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/LoadBalance.jl#L75">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.index_process_plot-Tuple{Any}" href="#Pigeons.index_process_plot-Tuple{Any}"><code>Pigeons.index_process_plot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">index_process_plot(recorders) -&gt; Plots.Plot
</code></pre><p>Given a <a href="../.interfaces/#Pigeons.recorders"><code>recorders</code></a>, create an index process plot.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/swap.jl#L97">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.informal_doc-Tuple{Any, Module}" href="#Pigeons.informal_doc-Tuple{Any, Module}"><code>Pigeons.informal_doc</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">informal_doc(doc_dir, mod::Module) -&gt; String
</code></pre><p>Generate informal interface documentation, e.g.: </p><pre><code class="nohighlight hljs">makedocs(;
    ...
    pages=[
        &quot;Home&quot; =&gt; &quot;index.md&quot;, 
        &quot;Interfaces&quot; =&gt; informal_doc(@__DIR__, MyModuleName),
        ...
    ]
)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/utils.jl#L172">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.initialization-Tuple{Any, SplittableRandoms.SplittableRandom, Int64}" href="#Pigeons.initialization-Tuple{Any, SplittableRandoms.SplittableRandom, Int64}"><code>Pigeons.initialization</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">initialization(
    state_initializer,
    rng::SplittableRandoms.SplittableRandom,
    chain::Int64
) -&gt; Any
</code></pre><p>Determine <a href="../.interfaces/#Pigeons.state_initializer"><code>state_initializer</code></a>&#39;s initialization for the given <code>chain</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/replicas.jl#L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.interpolate-Tuple{Any, Any}" href="#Pigeons.interpolate-Tuple{Any, Any}"><code>Pigeons.interpolate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate(path, beta) -&gt; Pigeons.InterpolatedLogPotential
</code></pre><p>Returns the <a href="../.interfaces/#Pigeons.log_potential"><code>log_potential</code></a> at point <code>beta</code> in the <a href="../.interfaces/#Pigeons.path"><code>path</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/path.jl#L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.load-Tuple{Any}" href="#Pigeons.load-Tuple{Any}"><code>Pigeons.load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">load(replicas) -&gt; Pigeons.LoadBalance
</code></pre><p>Return the <a href="../.interfaces/#Pigeons.replicas"><code>replicas</code></a>&#39;s <a href="#Pigeons.LoadBalance"><code>LoadBalance</code></a> (possibly <a href="#Pigeons.single_process_load-Tuple{Any}"><code>single_process_load</code></a>)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/replicas.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.local_exploration-NTuple{9, Any}" href="#Pigeons.local_exploration-NTuple{9, Any}"><code>Pigeons.local_exploration</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">local_exploration(states, kernels, optimreference_round, modref_means, modref_stds, 
    modref_covs, full_covariance, prior_sampler, n_explore)
    chainacceptance = Vector{Int64}(undef, length(states))</code></pre><p>Perform one local exploration move. <code>state</code> is the state from the <strong>one</strong>  previous scan, which is of size N+1[dim_x].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/exploration.jl#L1-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.locals-Tuple{Any}" href="#Pigeons.locals-Tuple{Any}"><code>Pigeons.locals</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">locals(replicas) -&gt; Vector
</code></pre><p>Return the replicas that are stored in this machine</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/replicas.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.log_unnormalized_ratio-Tuple{AbstractVector, Int64, Int64, Any}" href="#Pigeons.log_unnormalized_ratio-Tuple{AbstractVector, Int64, Int64, Any}"><code>Pigeons.log_unnormalized_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_unnormalized_ratio(
    log_potentials::AbstractVector,
    numerator::Int64,
    denominator::Int64,
    state
) -&gt; Any
</code></pre><p>Assumes the input <code>log_potentials</code> is a vector where each element is a <a href="../.interfaces/#Pigeons.log_potential"><code>log_potential</code></a>.</p><p>This default implementation is sufficient in most cases, but in less standard scenarios, e.g. where the state space is infinite dimensional, this can be overridden. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/log_potentials.jl#L29">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.log_unnormalized_ratio-Tuple{Any, Int64, Int64, Any}" href="#Pigeons.log_unnormalized_ratio-Tuple{Any, Int64, Int64, Any}"><code>Pigeons.log_unnormalized_ratio</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">log_unnormalized_ratio(
    log_potentials,
    numerator::Int64,
    denominator::Int64,
    state
) -&gt; Any
</code></pre><p>The argument <code>numerator</code> selects one distribution <span>$\pi_i$</span> from the collection <a href="../.interfaces/#Pigeons.log_potentials"><code>log_potentials</code></a>,  and similarly <code>denominator</code> selects <span>$\pi_j$</span>. Let <span>$x$</span> denote the input <code>state</code>. The ratio:</p><p class="math-container">\[f(x) = \frac{\text{d}\pi_i}{\text{d}\pi_j}(x)\]</p><p>may only be known up to a normalization constant which can depend on <span>$i$</span> and <span>$j$</span> but  not <span>$x$</span>, <span>$g(x) = C_{i,j} f(x)$</span>.</p><p>This function should return <span>$\log g$</span> evaluated at <code>state</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/log_potentials.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.lognormalizingconstant-Tuple{Any, Any}" href="#Pigeons.lognormalizingconstant-Tuple{Any, Any}"><code>Pigeons.lognormalizingconstant</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lognormalizingconstant(energies, schedule) -&gt; Any
</code></pre><p>Compute an estimate of the log normalizing constant given a vector of  <code>energies</code> and the corresponding annealing <code>schedule</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/utils.jl#L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.my_global_indices-Tuple{Pigeons.LoadBalance}" href="#Pigeons.my_global_indices-Tuple{Pigeons.LoadBalance}"><code>Pigeons.my_global_indices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">my_global_indices(
    lb::Pigeons.LoadBalance
) -&gt; UnitRange{Int64}
</code></pre><p>The slice of <code>lb.global_indices</code> this process is reponsible of.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/LoadBalance.jl#L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.my_load-Tuple{Pigeons.LoadBalance}" href="#Pigeons.my_load-Tuple{Pigeons.LoadBalance}"><code>Pigeons.my_load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">my_load(lb::Pigeons.LoadBalance) -&gt; Int64
</code></pre><p>Return the number of indices (task) this process is responsible of. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/LoadBalance.jl#L110">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.n_chains_global-Tuple{Any}" href="#Pigeons.n_chains_global-Tuple{Any}"><code>Pigeons.n_chains_global</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">n_chains_global(replicas) -&gt; Int64
</code></pre><p>Given a <a href="../.interfaces/#Pigeons.replicas"><code>replicas</code></a>, return the total number of chains across all processes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/replicas.jl#L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.one_per_host-Tuple{Any}" href="#Pigeons.one_per_host-Tuple{Any}"><code>Pigeons.one_per_host</code></a> — <span class="docstring-category">Method</span></header><section><div><p>For benchmarking purpose: subset the communicator so that at most one MPI process runs      in each machine.</p><p>Division is done so that original rank 0 is always included.</p><p>Return the new communicator or nothing if this machine is not in the subset. </p><p>See also &#39;-s&#39; option in mpi-run</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/one_per_host.jl#L1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.partner_chain-Tuple{Any, Int64}" href="#Pigeons.partner_chain-Tuple{Any, Int64}"><code>Pigeons.partner_chain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">partner_chain(swap_graph, chain::Int64) -&gt; Int64
</code></pre><p>For a given <a href="../.interfaces/#Pigeons.swap_graph"><code>swap_graph</code></a> and input <code>chain</code> index, what chain will it interact with at the current iteration? Convention: if a chain is not interacting, return its index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/swap_graph.jl#L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.permuted_get-Union{Tuple{T}, Tuple{PermutedDistributedArray{T}, AbstractVector{Int64}}} where T" href="#Pigeons.permuted_get-Union{Tuple{T}, Tuple{PermutedDistributedArray{T}, AbstractVector{Int64}}} where T"><code>Pigeons.permuted_get</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permuted_get(
    p::PermutedDistributedArray{T},
    indices::AbstractVector{Int64}
) -&gt; Vector
</code></pre><p>Retreive the values for the given <code>indices</code>, using MPI communication when needed. </p><p>We make the following assumptions:</p><ul><li><code>length(indices) == my_load(p.entangler.load)</code></li><li>the <code>indices</code> across all participating processes form a permutation of the global indices. </li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/PermutedDistributedArray.jl#L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.permuted_set!-Union{Tuple{T}, Tuple{PermutedDistributedArray{T}, AbstractVector{T}, AbstractVector{T}}} where T" href="#Pigeons.permuted_set!-Union{Tuple{T}, Tuple{PermutedDistributedArray{T}, AbstractVector{T}, AbstractVector{T}}} where T"><code>Pigeons.permuted_set!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">permuted_set!(
    p::PermutedDistributedArray{T},
    indices::AbstractArray{T, 1},
    new_values::AbstractArray{T, 1}
)
</code></pre><p>Set the values for the given <code>indices</code> to the given <code>new_values</code>, using MPI communication when needed. </p><p>We make the same assumptions as in <a href="#Pigeons.permuted_get-Union{Tuple{T}, Tuple{PermutedDistributedArray{T}, AbstractVector{Int64}}} where T"><code>permuted_get()</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/PermutedDistributedArray.jl#L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record!-Tuple{Any, Any}" href="#Pigeons.record!-Tuple{Any, Any}"><code>Pigeons.record!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record!(recorder, value) -&gt; Any
</code></pre><p>Add <code>value</code> to the statistics accumulated by <a href="../.interfaces/#Pigeons.recorder"><code>recorder</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/recorder.jl#L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record!-Tuple{OnlineStatsBase.OnlineStat, Any}" href="#Pigeons.record!-Tuple{OnlineStatsBase.OnlineStat, Any}"><code>Pigeons.record!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record!(recorder::OnlineStatsBase.OnlineStat, value) -&gt; Any
</code></pre><p>Forwards to OnlineStats&#39; <code>fit!</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/recorder.jl#L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record!-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K, Vector{V}}, Tuple{K, V}}} where {K, V}" href="#Pigeons.record!-Union{Tuple{V}, Tuple{K}, Tuple{Dict{K, Vector{V}}, Tuple{K, V}}} where {K, V}"><code>Pigeons.record!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record!(
    recorder::Dict{K, Array{V, 1}},
    value::Tuple{K, V}
) -&gt; Vector
</code></pre><p>Given a <code>value</code>, a pair <code>(a, b)</code>, and a <code>Dict{K, Vector{V}}</code> backed  <a href="../.interfaces/#Pigeons.recorder"><code>recorder</code></a>,  append <code>b</code> to the vector corresponding to <code>a</code>, inserting an empty  vector into the dictionary first if needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/recorder.jl#L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record_if_requested!-Tuple{NamedTuple, Any, Any}" href="#Pigeons.record_if_requested!-Tuple{NamedTuple, Any, Any}"><code>Pigeons.record_if_requested!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record_if_requested!(
    recorders::NamedTuple,
    recorder_key,
    value
) -&gt; Any
</code></pre><p>If the <a href="../.interfaces/#Pigeons.recorders"><code>recorders</code></a> contains the given <code>recorder_key</code>,  send the <code>value</code> to the <a href="@key"><code>recorder</code></a> corresponding to the  <code>recorder_key</code>. Otherwise, do nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/recorders.jl#L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record_swap_stats!-Tuple{Any, Any, Int64, Any, Int64, Any}" href="#Pigeons.record_swap_stats!-Tuple{Any, Any, Int64, Any, Int64, Any}"><code>Pigeons.record_swap_stats!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record_swap_stats!(
    pair_swapper,
    recorders,
    chain1::Int64,
    stat1,
    chain2::Int64,
    stat2
)
</code></pre><p>Given a <a href="../.interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a>, a <a href="../.interfaces/#Pigeons.recorders"><code>recorders</code></a>, the provided chain indices, and  the sufficient statistics computed by <a href="#Pigeons.swap_stat-Tuple{Any, Replica, Int64}"><code>swap_stat()</code></a>, record statistics. </p><p>To avoid accumulating twice the same statistic with (chain1, chain2) and  (chain2, chain2), <a href="#Pigeons.swap!-Tuple{Any, Any, Any}"><code>swap!()</code></a> only calls this for the pair with chain1 &lt; chain2.</p><p>By default, the following are accumulated:</p><ul><li>the swap acceptance probability.</li><li>TODO: stepping stone statistics.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/pair_swapper.jl#L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.record_swap_stats!-Tuple{Pigeons.TestSwapper, Any, Int64, Any, Int64, Any}" href="#Pigeons.record_swap_stats!-Tuple{Pigeons.TestSwapper, Any, Int64, Any, Int64, Any}"><code>Pigeons.record_swap_stats!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">record_swap_stats!(
    swapper::Pigeons.TestSwapper,
    recorder,
    chain1::Int64,
    stat1,
    chain2::Int64,
    stat2
)
</code></pre><p>See <a href="#Pigeons.TestSwapper"><code>TestSwapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/pair_swapper.jl#L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.recorder_keys-Tuple{Vararg{Symbol}}" href="#Pigeons.recorder_keys-Tuple{Vararg{Symbol}}"><code>Pigeons.recorder_keys</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">recorder_keys(args::Symbol...) -&gt; Set
</code></pre><p>Some statistics may induce memory requirements growing in  the number of iterations. Use this to select which ones,  if any to pass to <a href="#Pigeons.custom_recorders-Tuple{Set{Symbol}}"><code>custom_recorders()</code></a>. E.g.: <code>recorder_keys()</code> or <code>recorder_keys(:index_process)</code>.</p><p>Choices include (each specifying if it is included  in <a href="#Pigeons.default_recorders-Tuple{}"><code>default_recorders()</code></a>):</p><ul><li><code>:swap_acceptance_pr</code>: maintain swap acceptance probabilities,   a <code>GroupBy(Tuple{Int, Int}, Mean())</code> object   (included by default);</li><li><code>:index_process</code>: keep, for each replica, the list of    chains visited (not included by default), a    <code>Dict{Int, Vector{Int}}</code> object.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/recorders.jl#L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Entangler}} where T" href="#Pigeons.reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Entangler}} where T"><code>Pigeons.reduce_deterministically</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduce_deterministically(
    operation,
    source_data::AbstractArray{T, 1},
    e::Entangler
) -&gt; Any
</code></pre><p>Perform a binary <a href="https://en.wikipedia.org/wiki/MapReduce">reduction</a> of the  <code>source_data</code>, using MPI when needed. </p><p>Consider the binary tree with leaves given by the global indices specified in <code>e.load</code> and stored  in the different MPI processes&#39; input <code>source_data</code> vectors.  At each node of the tree, a reduction is performed using <code>operation</code>, i.e.  by calling <code>operation(left_child, right_child)</code>. When, and only when a branch of the tree crosses from one MPI process to another one,  MPI communication is used to transmit the intermediate reduction. </p><p>At the end, for process 1, <code>reduce_deterministically()</code> will return the root of the  binary tree, and for the other processes, <code>reduce_deterministically()</code> will return  <code>nothing</code>. </p><p>Note that even when the <code>operation</code> is only approximately associative (typical situation  for floating point reductions), the output of this function is invariant to the  number of MPI processes involved (hence the terminology &#39;deterministically&#39;).  This contrasts to direct use of MPI collective communications where the leaves are  MPI processes and hence will give slightly different outputs given different  numbers of MPI processes. In the context of randomized algorithms, these minor  differences are then amplified. </p><p>In contrast to <a href="#Pigeons.transmit!-Union{Tuple{T}, Tuple{Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T"><code>transmit!()</code></a>, we do not assume <code>isbitstype(T) == true</code> and use  serialization when messages are transmitted over MPI.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/Entanglement.jl#L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.reduced_recorders-Tuple{Any}" href="#Pigeons.reduced_recorders-Tuple{Any}"><code>Pigeons.reduced_recorders</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reduced_recorders(replicas) -&gt; Any
</code></pre><p>Perform a reduction across all the replicas&#39; individual recorders,  using  <a href="#Pigeons.combine-Tuple{Any, Any}"><code>combine()</code></a> on each individual <a href="../.interfaces/#Pigeons.recorder"><code>recorder</code></a> held. Returns a <a href="../.interfaces/#Pigeons.recorders"><code>recorders</code></a> with all the information merged. </p><p>Since this uses <a href="#Pigeons.all_reduce_deterministically-Union{Tuple{T}, Tuple{Any, AbstractVector{T}, Entangler}} where T"><code>all_reduce_deterministically</code></a>, the output is  identical, no matter how many MPI processes are used, even when  the reduction involves only approximately associative <a href="#Pigeons.combine-Tuple{Any, Any}"><code>combine()</code></a> operations (e.g. most floating point ones).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/recorders.jl#L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.reference_chains-Tuple{Any}" href="#Pigeons.reference_chains-Tuple{Any}"><code>Pigeons.reference_chains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reference_chains(swap_graph) -&gt; Set{Int64}
</code></pre><p>Given a <a href="../.interfaces/#Pigeons.swap_graph"><code>swap_graph</code></a>, return the set of chain(s) targeting a reference distribution. These are typically tractable in the sense that we can sample i.i.d. from them. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/swap_graph.jl#L18">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.restarts-Tuple{Any}" href="#Pigeons.restarts-Tuple{Any}"><code>Pigeons.restarts</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">restarts(indices_matrix; cumulative) -&gt; Any
</code></pre><p>Compute the number of restarts for a given index process trajectory.  Otherwise, it is the same as <code>roundtrip()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/restarts.jl#L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.roundtrip-Tuple{Any}" href="#Pigeons.roundtrip-Tuple{Any}"><code>Pigeons.roundtrip</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">roundtrip(indices_matrix; cumulative) -&gt; Any
</code></pre><p>Compute the number of round trips for a given index process trajectory.  <code>indices_matrix</code> is a matrix containing information about the index process. <code>cumulative</code> indicates whether we should store the output as a vector containing  information about the number of total round trips up to sample <code>n</code>. If false, the output is a scalar.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/restarts.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.scaled_normal_example-Tuple{Any, Any}" href="#Pigeons.scaled_normal_example-Tuple{Any, Any}"><code>Pigeons.scaled_normal_example</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">scaled_normal_example(n_chains, dim) -&gt; Any
</code></pre><p>Toy path for testing: see section I.4.1 in Syed et al 2021. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/path_implementations.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.setkernels-Tuple{Any, Any}" href="#Pigeons.setkernels-Tuple{Any, Any}"><code>Pigeons.setkernels</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setkernels(potential, etas)</code></pre><p>Set the local exploration kernels given the <code>potential</code> and the annealing  parameters, <code>etas</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/exploration.jl#L52-L57">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.single_process_load-Tuple{Any}" href="#Pigeons.single_process_load-Tuple{Any}"><code>Pigeons.single_process_load</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">single_process_load(n_global_indices) -&gt; Pigeons.LoadBalance
</code></pre><p>A load balance with only one process.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/LoadBalance.jl#L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.slice_accept-Tuple{SS, Any, Vector{Float64}, Any, Float64, Float64, Float64, Int64}" href="#Pigeons.slice_accept-Tuple{SS, Any, Vector{Float64}, Any, Float64, Float64, Float64, Int64}"><code>Pigeons.slice_accept</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice_accept(h::SS, g, x_0, x_1, z, L, R, c)</code></pre><p>Test whether to accept the current slice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/samplers/slice_sample.jl#L72-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.slice_double-Tuple{SS, Any, Vector{Float64}, Float64, Int64}" href="#Pigeons.slice_double-Tuple{SS, Any, Vector{Float64}, Float64, Int64}"><code>Pigeons.slice_double</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice_double(h, g, x_0, z, c)</code></pre><p>Double the current slice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/samplers/slice_sample.jl#L12-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.slice_sample-Tuple{SS, Vector{Float64}, Int64}" href="#Pigeons.slice_sample-Tuple{SS, Vector{Float64}, Int64}"><code>Pigeons.slice_sample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice_sample(h::SS, x_0::Vector{Float64}, nsamps::Int)</code></pre><p>Slice sample <code>nsamps</code> given a starting vector  <code>x_0</code> and the struct <code>h</code>  that contains information about the log-density.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/samplers/slice_sample.jl#L112-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.slice_shrink-Tuple{SS, Any, Vector{Float64}, Float64, Float64, Float64, Int64}" href="#Pigeons.slice_shrink-Tuple{SS, Any, Vector{Float64}, Float64, Float64, Float64, Int64}"><code>Pigeons.slice_shrink</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">slice_shrink(h, g, x_0, z, L, R, c)</code></pre><p>Shrink the current slice.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/samplers/slice_sample.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.split_slice-Tuple{UnitRange, Any}" href="#Pigeons.split_slice-Tuple{UnitRange, Any}"><code>Pigeons.split_slice</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">split_slice(slice::UnitRange, rng) -&gt; Any
</code></pre><p>From one splittable random object, one can conceptualize an infinite list of splittable random objects.  Return a slice from this infinite list.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/utils.jl#L81">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap!-Tuple{Any, Any, Any}" href="#Pigeons.swap!-Tuple{Any, Any, Any}"><code>Pigeons.swap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap!(pair_swapper, replicas, swap_graph)
</code></pre><p>For each pair of chains encoded in <a href="../.interfaces/#Pigeons.swap_graph"><code>swap_graph</code></a>, use  <a href="../.interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a> to decide if the pair will swap or not,  and write the changes in-place into <a href="../.interfaces/#Pigeons.replicas"><code>replicas</code></a> (i.e. exchanging  the <code>Replica</code>&#39;s <code>chain</code> fields for those that swapped.)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/replicas.jl#L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap!-Tuple{Any, EntangledReplicas, Any}" href="#Pigeons.swap!-Tuple{Any, EntangledReplicas, Any}"><code>Pigeons.swap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap!(pair_swapper, replicas::EntangledReplicas, swap_graph)
</code></pre><p>Entangled MPI <code>swap!</code> implementation.</p><p>This implementation is designed to support distributed PT with the following guarantees</p><ul><li>The running time is independent of the size of the state space      (&#39;swapping annealing parameters rather than states&#39;)</li><li>The output is identical no matter how many MPI processes are used. In particular,      this means that we can check correctness by comparing to the serial, single-process version.</li><li>Scalability to 1000s of processes communicating over MPI (see details below).</li><li>The same function can be used when a single process is used and MPI is not available.</li><li>Flexibility to extend PT to e.g. networks of targets and general paths.</li></ul><p>Running time analysis:</p><p>Let <span>$N$</span> denote the number of chains, <span>$P$</span>, the number of processes, and <span>$K = \text{ceil}(N/P)$</span>,   the maximum number of chains held by one process.  Assuming the running time is dominated by communication latency and  a constant time for the latency of each   peer-to-peer communication, the theoretical running time is <span>$O(K)$</span>.  In practice, latency will grow as a function of <span>$P$</span>, but empirically, this growth appears to be slow enough that for say <span>$P = N =$</span> a few 1000s,  swapping will not be the computational bottleneck.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/swap.jl#L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap!-Union{Tuple{R}, Tuple{Any, Vector{R}, Any}} where R" href="#Pigeons.swap!-Union{Tuple{R}, Tuple{Any, Vector{R}, Any}} where R"><code>Pigeons.swap!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap!(pair_swapper, replicas::Array{R, 1}, swap_graph)
</code></pre><p>Single process, non-allocating <code>swap!</code> implementation. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/swap.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap_decision-Tuple{Any, Int64, Any, Int64, Any}" href="#Pigeons.swap_decision-Tuple{Any, Int64, Any, Int64, Any}"><code>Pigeons.swap_decision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap_decision(
    pair_swapper,
    chain1::Int64,
    stat1,
    chain2::Int64,
    stat2
) -&gt; Bool
</code></pre><p>Given a <a href="../.interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a>, a <a href="../.interfaces/#Pigeons.recorders"><code>recorders</code></a>, the provided chain indices, and  the sufficient statistics computed by <a href="#Pigeons.swap_stat-Tuple{Any, Replica, Int64}"><code>swap_stat()</code></a>, make a swap decision.</p><p>By default, this is done as follows:</p><ol><li>compute the standard swap acceptance probability <code>min(1, exp(stat1.log_ratio + stat2.log_ratio))</code></li><li>make sure the two chains share the same uniform by picking the uniform from the chain with the smallest chain index </li><li>swap if the shared uniform is smaller than the swap acceptance probability.</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/pair_swapper.jl#L71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap_decision-Tuple{Pigeons.TestSwapper, Int64, Float64, Int64, Float64}" href="#Pigeons.swap_decision-Tuple{Pigeons.TestSwapper, Int64, Float64, Int64, Float64}"><code>Pigeons.swap_decision</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap_decision(
    swapper::Pigeons.TestSwapper,
    chain1::Int64,
    stat1::Float64,
    chain2::Int64,
    stat2::Float64
) -&gt; Bool
</code></pre><p>See <a href="#Pigeons.TestSwapper"><code>TestSwapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/pair_swapper.jl#L118">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap_stat-Tuple{Any, Replica, Int64}" href="#Pigeons.swap_stat-Tuple{Any, Replica, Int64}"><code>Pigeons.swap_stat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap_stat(
    pair_swapper,
    replica::Replica,
    partner_chain::Int64
) -&gt; Float64
</code></pre><p>By default, two sufficient statistics are computed and stored in the <a href="#Pigeons.SwapStat"><code>SwapStat</code></a> struct:</p><ul><li>The result of calling <a href="#Pigeons.log_unnormalized_ratio-Tuple{AbstractVector, Int64, Int64, Any}"><code>log_unnormalized_ratio()</code></a> on <a href="../.interfaces/#Pigeons.pair_swapper"><code>pair_swapper</code></a></li><li>A uniform number to coordinate the swap decision.</li></ul><p>This can be extended by dispatching on other <code>pair_swapper</code> types, with the  constraint that the returned sufficient statistics should satisfy <code>isbitstype()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/pair_swapper.jl#L31">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.swap_stat-Tuple{Pigeons.TestSwapper, Replica, Int64}" href="#Pigeons.swap_stat-Tuple{Pigeons.TestSwapper, Replica, Int64}"><code>Pigeons.swap_stat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap_stat(
    swapper::Pigeons.TestSwapper,
    replica::Replica,
    partner_chain::Int64
) -&gt; Float64
</code></pre><p>See <a href="#Pigeons.TestSwapper"><code>TestSwapper</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/pair_swapper.jl#L111">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.target_chains-Tuple{Any}" href="#Pigeons.target_chains-Tuple{Any}"><code>Pigeons.target_chains</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">target_chains(swap_graph) -&gt; Set{Int64}
</code></pre><p>Given a <a href="../.interfaces/#Pigeons.swap_graph"><code>swap_graph</code></a>, return the set of chain(s) targeting a distribution of interest. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/swap_graph.jl#L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.transmit!-Union{Tuple{T}, Tuple{Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T" href="#Pigeons.transmit!-Union{Tuple{T}, Tuple{Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T"><code>Pigeons.transmit!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transmit!(
    e::Entangler,
    source_data::AbstractArray{T, 1},
    to_global_indices::AbstractVector{Int64},
    write_received_data_here::Array{T, 1}
)
</code></pre><p>Use MPI point-to-point communication to  permute the contents of <code>source_data</code> across MPI processes, writing the permuted data into  <code>write_received_data_here</code>.  The permutation is specified by the load balance in the input argument <code>e</code> as well as the  argument <code>to_global_indices</code>.</p><p>More precisely, assume the Vectors <code>source_data</code>, <code>to_global_indices</code>, and <code>write_received_data_here</code>  are all of the length specified in <code>my_load(e.load)</code>. </p><p>For each <code>i</code>, <code>source_data[i]</code> is sent to MPI process <code>p = find_process(e.load, g)</code>,  where <code>g = to_global_indices[i]</code> and  written into this <code>p</code> &#39;s <code>write_received_data_here[j]</code>, where <code>j = find_local_index(e.load, g)</code></p><p>See Entangler&#39;s comments regarding the requirement that all machines call transmit() the  same number of times and at logically related intervals. </p><p>Additionally, at each micro-iteration, we assume that  <code>{to_global_indices_p : p ranges over the difference processes}</code> forms a partition of  <code>{1, ..., e.load.n_global_indices}</code> If ran in single-process mode, this &#39;partition property&#39; is checked;  if ran in multi-process, opportunistic checks will be made, namely when several entries in <code>to_global_indices</code>  lie in the same process, but systematic checks are not made for performance reasons. </p><p>We also assume <code>isbitstype(T) == true</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/Entanglement.jl#L90">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.transmit-Union{Tuple{T}, Tuple{Entangler, AbstractVector{T}, AbstractVector{Int64}}} where T" href="#Pigeons.transmit-Union{Tuple{T}, Tuple{Entangler, AbstractVector{T}, AbstractVector{Int64}}} where T"><code>Pigeons.transmit</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transmit(
    e::Entangler,
    source_data::AbstractArray{T, 1},
    to_global_indices::AbstractVector{Int64}
) -&gt; Vector
</code></pre><p>The same as <a href="#Pigeons.transmit!-Union{Tuple{T}, Tuple{Entangler, AbstractVector{T}, AbstractVector{Int64}, Vector{T}}} where T"><code>transmit!()</code></a> but instead of writing the result to an input argument, provide the result  as a returned <code>Vector</code>. </p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/mpi_utils/Entanglement.jl#L77">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.updateschedule-Tuple{Any, Int64}" href="#Pigeons.updateschedule-Tuple{Any, Int64}"><code>Pigeons.updateschedule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">updateschedule(
    cumulativebarrier,
    N::Int64
) -&gt; Vector{Float64}
</code></pre><p>Update the annealing schedule. Given the cumulative communication barrier function in <code>cumulativebarrier</code>, find the optimal schedule of size <code>N</code>+1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/adaptation.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.winsorized_mean-Tuple{Any}" href="#Pigeons.winsorized_mean-Tuple{Any}"><code>Pigeons.winsorized_mean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">winsorized_mean(x; α) -&gt; Any
</code></pre><p>Compute the winsorized mean from an input <code>x</code>, which is assumed to be a vector of vectors.  <code>α</code> denotes the percentage of observations to winsorize at the bottom and the top  so that we use 1 - 2α observations and winsorize the rest.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/utils.jl#L1">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.winsorized_std-Tuple{Any}" href="#Pigeons.winsorized_std-Tuple{Any}"><code>Pigeons.winsorized_std</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">winsorized_std(x; α) -&gt; Any
</code></pre><p>Compute the winsorized standard deviation. The parameters are the same  as those for <code>winsorized_mean()</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/utils.jl#L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Pigeons.@informal-Tuple{Symbol, Expr}" href="#Pigeons.@informal-Tuple{Symbol, Expr}"><code>Pigeons.@informal</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@informal name begin ... end</code></pre><p>Document an informal interface with provided <code>name</code>, and functions  specified in a <code>begin .. end</code> block. </p><p><code>@informal</code> will spit back the contents of the <code>begin .. end</code> block so  this macro can be essentially ignored at first read. </p><p>When building documentation, this allows us to use the  function <a href="#Pigeons.informal_doc-Tuple{Any, Module}"><code>informal_doc()</code></a> to automatically document the  informal interface.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/Julia-Tempering/Pigeons.jl/blob/a966c34ee8fdeff85041ebebf03c5794124c6280/src/utils.jl#L125-L137">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../.interfaces/">« Interfaces</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 6 January 2023 07:05">Friday 6 January 2023</span>. Using Julia version 1.8.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
